<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wormoney v2.0 - Modular Refactor</title>
    <style>
        /* --- GLOBAL STYLES --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            cursor: crosshair;
            touch-action: none; 
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- UI OVERLAYS --- */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        .ui-info {
            bottom: 20px;
            left: 20px;
            opacity: 0.5;
            font-size: 14px;
            color: #888;
        }

        .tutorial-hint {
            top: 20%;
            width: 40%;
            text-align: center;
            color: rgba(255,255,255,0.3);
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* --- MENU & MODALS --- */
        #main-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            display: flex;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(5px);
            touch-action: none;
            pointer-events: auto;
        }

        .menu-option {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s ease;
            position: relative;
        }

        .menu-option:first-child {
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        .menu-option:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .menu-option:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .icon-area { font-size: 60px; margin-bottom: 20px; }
        .menu-title { font-size: 28px; font-weight: 700; letter-spacing: 1px; margin-bottom: 10px; }
        .menu-desc { font-size: 14px; color: #aaa; max-width: 250px; text-align: center; line-height: 1.5; }

        #or-divider {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            padding: 10px;
            border-radius: 50%;
            z-index: 2;
            color: #888;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        /* --- JOYSTICK --- */
        #joystick-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 50;
            overflow: hidden;
        }

        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            display: none; 
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <!-- GAME CANVAS -->
    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER: DESKTOP -->
    <div id="ui-desktop" class="ui-layer ui-info" style="display: none;">
        LMB/RMB - Boost | Mouse - Move
    </div>

    <!-- UI LAYER: MOBILE / JOYSTICK -->
    <div id="joystick-ui">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
        <div class="ui-layer tutorial-hint" style="left: 5%; display: none;" id="hint-move">Touch & Hold<br>to Move</div>
        <div class="ui-layer tutorial-hint" style="right: 5%; display: none;" id="hint-boost">Touch & Hold<br>to Boost</div>
    </div>

    <!-- MAIN MENU (Input Selection) -->
    <div id="main-menu-overlay">
        <div id="or-divider">OR</div>
        
        <!-- Option 1: Mobile -->
        <div class="menu-option" id="btn-mode-mobile">
            <div class="icon-area">ðŸ“±</div>
            <div class="menu-title">MOBILE</div>
            <div class="menu-desc">
                Fast & Optimized<br>
                Static Background<br>
                Joystick Controls
            </div>
        </div>

        <!-- Option 2: Desktop -->
        <div class="menu-option" id="btn-mode-desktop">
            <div class="icon-area">ðŸ’»</div>
            <div class="menu-title">DESKTOP</div>
            <div class="menu-desc">
                Full Visuals<br>
                Animated Background<br>
                Mouse Controls
            </div>
        </div>
    </div>

    <script>
        /**
         * ==========================================
         * MODULE 1: CONFIGURATION & CONSTANTS
         * ==========================================
         * Centralized settings for easy tweaking.
         */
        const Config = {
            Background: {
                hexSize: 21.6,
                hexGap: 9, 
                hue: 215,
                saturation: 9,
                lightnessEdge: 2.5,
                centerMinL: 4.2,
                centerMaxL: 6.8,
                animSpeed: 0.001,
                centerL: 5.5, 
            },
            Game: {
                baseSpeed: 1.7,     
                boostSpeed: 3.3,     
                turnSpeed: 0.044, 
                targetLengthPx: 82, 
                snakeRadius: 9.2,
                renderGap: 1,
                eyeFollowSpeed: 0.15,
                targetVisibleArea: 345000,
                worldRadius: 1500
            },
            Minimap: {
                radius: 75,
                margin: 20,
                bgCenter: 'rgba(20, 20, 30, 0.4)', 
                bgEdge: 'rgba(10, 10, 20, 0.6)',
                borderColor: 'rgba(52, 0, 90, 0.9)', 
                playerColor: '#00d2ff'
            },
            Colors: {
                defaultSkin: '#1a52bd',
                shadow: 'rgba(0, 0, 0, 0.4)',
                boostGlow: 'rgba(255, 255, 255, 0.8)',
                boundary: 'rgba(255, 50, 50, 0.6)'
            }
        };

        /**
         * ==========================================
         * MODULE 2: UTILITIES
         * ==========================================
         * Static helper functions.
         */
        class Utils {
            static lerpAngle(a, b, t) {
                let diff = b - a;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return a + diff * t;
            }

            static getLerpFactor(baseRate, timeScale) {
                return 1 - Math.pow(1 - baseRate, timeScale);
            }

            static getPseudoRandom(x, y) {
                return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            }

            static clamp(val, min, max) {
                return Math.max(min, Math.min(max, val));
            }
        }

        /**
         * ==========================================
         * MODULE 3: SYSTEM MANAGERS
         * ==========================================
         */

        /**
         * NETWORK MANAGER (Placeholder)
         * Future: Handle WebSockets, state synchronization for multiplayer.
         */
        class NetworkManager {
            constructor() {
                this.isConnected = false;
                this.socket = null;
            }
            connect(serverUrl) { console.log(`Connecting to ${serverUrl}...`); }
            sendInput(inputData) { /* Emit input state to server */ }
            onGameStateUpdate(callback) { /* Listen for server tick */ }
        }

        /**
         * SKIN MANAGER (Placeholder)
         * Future: Handle skin selection, loading assets, customization.
         */
        class SkinManager {
            constructor() {
                this.currentSkin = Config.Colors.defaultSkin;
            }
            setSkin(skinId) { this.currentSkin = skinId; }
            getSkin() { return this.currentSkin; }
        }

        /**
         * INPUT MANAGER
         * Handles Mouse (Desktop) and Touch/Joystick (Mobile) logic.
         * Decouples raw events from game state.
         */
        class InputManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.state = {
                    mode: 'desktop', // 'desktop' | 'mobile'
                    mouseX: window.innerWidth / 2,
                    mouseY: window.innerHeight / 2,
                    mouseDown: false,
                    activePointerId: null
                };

                // Joystick specific internal state
                this.joystick = {
                    active: false,
                    origin: { x: 0, y: 0 },
                    current: { x: 0, y: 0 },
                    radius: 40,
                    id: null
                };

                // DOM Elements for Joystick
                this.ui = {
                    base: document.getElementById('joystick-base'),
                    stick: document.getElementById('joystick-stick'),
                    hintMove: document.getElementById('hint-move'),
                    hintBoost: document.getElementById('hint-boost')
                };

                this.boostPointers = new Set();
            }

            setMode(mode) {
                this.state.mode = mode;
                if (mode === 'desktop') this._initDesktop();
                else this._initMobile();
            }

            _initDesktop() {
                window.addEventListener('mousemove', e => {
                    this.state.mouseX = e.clientX;
                    this.state.mouseY = e.clientY;
                });
                window.addEventListener('mousedown', () => this.state.mouseDown = true);
                window.addEventListener('mouseup', () => this.state.mouseDown = false);
            }

            _initMobile() {
                // Pointer events for multitouch support
                window.addEventListener('pointerdown', this._handlePointerDown.bind(this), { passive: false });
                window.addEventListener('pointermove', this._handlePointerMove.bind(this), { passive: false });
                window.addEventListener('pointerup', this._handlePointerUp.bind(this), { passive: false });
                window.addEventListener('pointercancel', this._handlePointerUp.bind(this), { passive: false });
                window.addEventListener('contextmenu', e => e.preventDefault());
            }

            _handlePointerDown(e) {
                e.preventDefault();
                const { clientX: x, clientY: y, pointerId } = e;

                // Capture pointer to canvas to track movement outside bounds
                try { this.canvas.setPointerCapture(pointerId); } catch (err) {}

                // Left side of screen = Joystick
                if (x < window.innerWidth / 2) {
                    if (this.joystick.active) {
                        this.joystick.active = false;
                        this.ui.base.style.display = 'none';
                    }
                    this.joystick.active = true;
                    this.joystick.id = pointerId;
                    this.joystick.origin = { x, y };
                    this.joystick.current = { x, y };

                    // Visual update
                    this.ui.base.style.display = 'block';
                    this.ui.base.style.left = x + 'px';
                    this.ui.base.style.top = y + 'px';
                    this.ui.stick.style.transform = `translate(-50%, -50%)`;
                    if(this.ui.hintMove) this.ui.hintMove.style.display = 'none';
                } 
                // Right side of screen = Boost
                else {
                    this.boostPointers.add(pointerId);
                    this.state.mouseDown = true;
                    if(this.ui.hintBoost) this.ui.hintBoost.style.display = 'none';
                }
            }

            _handlePointerMove(e) {
                e.preventDefault();
                if (this.joystick.active && e.pointerId === this.joystick.id) {
                    const dx = e.clientX - this.joystick.origin.x;
                    const dy = e.clientY - this.joystick.origin.y;
                    const angle = Math.atan2(dy, dx);
                    const dist = Math.min(Math.hypot(dx, dy), this.joystick.radius);
                    
                    // Update stick visual
                    const stickX = Math.cos(angle) * dist;
                    const stickY = Math.sin(angle) * dist;
                    this.ui.stick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;

                    // Project virtual mouse position for snake steering
                    const projectionDist = 500;
                    this.state.mouseX = (window.innerWidth / 2) + Math.cos(angle) * projectionDist;
                    this.state.mouseY = (window.innerHeight / 2) + Math.sin(angle) * projectionDist;
                }
            }

            _handlePointerUp(e) {
                e.preventDefault();
                if (this.joystick.active && e.pointerId === this.joystick.id) {
                    this.joystick.active = false;
                    this.joystick.id = null;
                    this.ui.base.style.display = 'none';
                }
                if (this.boostPointers.has(e.pointerId)) {
                    this.boostPointers.delete(e.pointerId);
                    if (this.boostPointers.size === 0) this.state.mouseDown = false;
                }
                try { this.canvas.releasePointerCapture(e.pointerId); } catch(err){}
            }

            getInputState() {
                return this.state;
            }
        }

        /**
         * RENDER ENGINE
         * Handles Canvas Context, Caching, and Drawing primitives.
         */
        class RenderEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: false });
                this.width = canvas.width;
                this.height = canvas.height;
                
                // Settings
                this.highQuality = false;

                // Cache storage
                this.cache = {
                    mobileHex: null,
                    minimapBg: null,
                    vignette: null,
                    hexOffsets: []
                };

                this._initGeometryCache();
            }

            resize(w, h) {
                this.width = w;
                this.height = h;
                this.canvas.width = w;
                this.canvas.height = h;
                // Re-generate dependent caches
                if (this.highQuality) this.updateVignetteCache();
            }

            setQuality(isHigh) {
                this.highQuality = isHigh;
                // Generate/Clear caches based on quality
                this._initHexCache();
                this._initMinimapCache();
                this.updateVignetteCache();
            }

            clear() {
                this.ctx.resetTransform();
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            // --- Caching Logic ---

            _initGeometryCache() {
                const r = Config.Background.hexSize;
                const drawR = Math.max(0, r - (Config.Background.hexGap / 2));
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 180) * (60 * i);
                    this.cache.hexOffsets.push({
                        x: drawR * Math.cos(angle),
                        y: drawR * Math.sin(angle)
                    });
                }
            }

            _initHexCache() {
                const r = Config.Background.hexSize;
                const drawR = Math.max(0, r - (Config.Background.hexGap / 2));
                const size = Math.ceil(drawR * 2 + 2);
                
                const c = document.createElement('canvas');
                c.width = size;
                c.height = size;
                const ctx = c.getContext('2d');
                const cx = size/2, cy = size/2;

                const colorCenter = `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, ${Config.Background.centerL}%)`;
                const colorEdge = `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, ${Config.Background.lightnessEdge}%)`;

                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                     const angle = (Math.PI / 180) * (60 * i);
                     const px = cx + drawR * Math.cos(angle);
                     const py = cy + drawR * Math.sin(angle);
                     if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, drawR);
                grad.addColorStop(0, colorCenter);
                grad.addColorStop(1, colorEdge);
                ctx.fillStyle = grad;
                ctx.fill();

                this.cache.mobileHex = c;
            }

            _initMinimapCache() {
                const { radius, margin, bgCenter, bgEdge, borderColor } = Config.Minimap;
                const size = (radius + margin) * 2;
                const c = document.createElement('canvas');
                c.width = size;
                c.height = size;
                const ctx = c.getContext('2d');
                const cx = size/2, cy = size/2;

                const grad = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.1, cx, cy, radius);
                grad.addColorStop(0, bgCenter);
                grad.addColorStop(1, bgEdge);

                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI*2);
                ctx.clip();
                ctx.fillStyle = grad;
                ctx.fill();

                // Border
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI*2);
                ctx.lineWidth = 3;
                ctx.strokeStyle = borderColor;
                ctx.stroke();

                this.cache.minimapBg = c;
            }

            updateVignetteCache() {
                if (!this.highQuality) {
                    this.cache.vignette = null;
                    return;
                }
                const c = document.createElement('canvas');
                c.width = this.width;
                c.height = this.height;
                const ctx = c.getContext('2d');
                const vRadius = Math.hypot(this.width/2, this.height/2);
                const grad = ctx.createRadialGradient(this.width/2, this.height/2, vRadius*0.4, this.width/2, this.height/2, vRadius);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, 'rgba(0,0,0,0.95)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, this.width, this.height);
                this.cache.vignette = c;
            }
        }

        /**
         * ==========================================
         * MODULE 4: ENTITIES
         * ==========================================
         */

        /**
         * ENTITY BASE
         * Base class for all game objects.
         */
        class Entity {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.markedForDeletion = false;
            }
            update(dt) {}
            draw(ctx) {}
        }

        /**
         * SNAKE CLASS
         * Handles physics, body segments, and rendering of the snake.
         */
        class Snake extends Entity {
            constructor() {
                super(0, 0);
                this.reset();
                this.skinColor = Config.Colors.defaultSkin;
                this.headSprite = this._createHeadSprite(this.skinColor);
            }

            reset() {
                this.x = 0;
                this.y = 0;
                this.angle = -Math.PI / 2;
                this.targetAngle = this.angle;
                this.lookAngle = 0;
                this.radius = Config.Game.snakeRadius;
                this.boosting = false;
                this.dashOffset = 0;
                
                // Path/Body Init
                this.path = [];
                for(let i=0; i < 50; i++) {
                    this.path.push({x: this.x, y: this.y + (i * 2)});
                }

                // Eye State
                this.blinkTimer = Math.random() * 200 + 100;
                this.blinkState = 0; 
                this.eyeOpenness = 1.0;
            }

            _createHeadSprite(color) {
                const r = this.radius;
                const size = r * 2 + 4;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');
                const center = size / 2;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(center, center, r, 0, Math.PI*2);
                ctx.fill();

                const grad = ctx.createRadialGradient(center - r*0.3, center - r*0.3, 0, center, center, r);
                grad.addColorStop(0, 'rgba(255,255,255,0.25)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(center, center, r, 0, Math.PI*2);
                ctx.fill();
                return c;
            }

            update(timeScale, inputState, worldRadius, isHighQuality) {
                // 1. INPUT PROCESSING
                const dx = inputState.mouseX - (window.innerWidth / 2);
                const dy = inputState.mouseY - (window.innerHeight / 2);
                this.targetAngle = Math.atan2(dy, dx);
                this.boosting = inputState.mouseDown;

                // 2. TURN PHYSICS
                const turnRate = Utils.getLerpFactor(Config.Game.turnSpeed, timeScale);
                this.angle = Utils.lerpAngle(this.angle, this.targetAngle, turnRate);

                // 3. EYE MECHANICS (High Quality Only)
                if (isHighQuality) {
                    this._updateEyes(timeScale);
                }

                // 4. MOVEMENT
                let currentSpeed = this.boosting ? Config.Game.boostSpeed : Config.Game.baseSpeed;
                currentSpeed *= timeScale;
                this.dashOffset -= currentSpeed * 1.5;

                let nextX = this.x + Math.cos(this.angle) * currentSpeed;
                let nextY = this.y + Math.sin(this.angle) * currentSpeed;

                // 5. BOUNDARY CHECK
                const limit = worldRadius - this.radius;
                if (nextX * nextX + nextY * nextY > limit * limit) {
                    this.reset();
                    return;
                }

                this.x = nextX;
                this.y = nextY;

                // 6. BODY SEGMENTS LOGIC
                this.path.unshift({x: this.x, y: this.y});
                let accumulatedLen = 0;
                for (let i = 0; i < this.path.length - 1; i++) {
                    const p1 = this.path[i];
                    const p2 = this.path[i+1];
                    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    if (accumulatedLen + dist > Config.Game.targetLengthPx) {
                        const ratio = (Config.Game.targetLengthPx - accumulatedLen) / dist;
                        p2.x = p1.x + (p2.x - p1.x) * ratio;
                        p2.y = p1.y + (p2.y - p1.y) * ratio;
                        this.path.length = i + 2;
                        break;
                    }
                    accumulatedLen += dist;
                }
            }

            _updateEyes(timeScale) {
                let desiredLookAngle = this.targetAngle - this.angle;
                while (desiredLookAngle > Math.PI) desiredLookAngle -= Math.PI * 2;
                while (desiredLookAngle < -Math.PI) desiredLookAngle += Math.PI * 2;
                desiredLookAngle = Utils.clamp(desiredLookAngle, -Math.PI/2.2, Math.PI/2.2);

                const eyeRate = Utils.getLerpFactor(Config.Game.eyeFollowSpeed, timeScale);
                this.lookAngle = Utils.lerpAngle(this.lookAngle, desiredLookAngle, eyeRate);

                // Blinking Logic
                this.blinkTimer -= timeScale;
                const blinkSpeed = 10;

                if (this.blinkState === 0) { // State 0: Normal Open
                    this.eyeOpenness = 1.0;
                    if (this.blinkTimer <= 0) { 
                        this.blinkState = 1; 
                        this.blinkTimer = blinkSpeed; 
                    }
                } 
                else if (this.blinkState === 1) { // State 1: Closing
                    if (this.blinkTimer <= 0) { 
                        this.blinkState = 2; 
                        this.blinkTimer = blinkSpeed;
                        this.eyeOpenness = 0.0;
                    } else {
                        this.eyeOpenness = this.blinkTimer / blinkSpeed;
                    }
                } 
                else if (this.blinkState === 2) { // State 2: Opening
                    if (this.blinkTimer <= 0) { 
                        this.blinkState = 0; 
                        this.blinkTimer = Math.random() * 200 + 150; 
                        this.eyeOpenness = 1.0;
                    } else {
                        this.eyeOpenness = 1.0 - (this.blinkTimer / blinkSpeed);
                    }
                }
                
                // Final Safety Clamp to prevent rendering glitches
                this.eyeOpenness = Utils.clamp(this.eyeOpenness, 0, 1);
            }

            draw(ctx, isHighQuality) {
                if (this.path.length < 2) return;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Shadow
                ctx.beginPath();
                ctx.moveTo(this.path[0].x + 4, this.path[0].y + 6);
                for (let i = 1; i < this.path.length; i++) ctx.lineTo(this.path[i].x + 4, this.path[i].y + 6);
                ctx.strokeStyle = Config.Colors.shadow;
                ctx.lineWidth = this.radius * 2;
                if (isHighQuality) { ctx.shadowBlur = 15; ctx.shadowColor = "rgba(0,0,0,0.6)"; }
                ctx.stroke();
                if (isHighQuality) { ctx.shadowBlur = 0; ctx.shadowColor = "transparent"; }

                // Body Construction
                ctx.beginPath();
                ctx.moveTo(this.path[0].x, this.path[0].y);
                for (let i = 1; i < this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y);

                // Boost Glow
                if (this.boosting) {
                    ctx.save();
                    ctx.strokeStyle = Config.Colors.boostGlow;
                    ctx.lineWidth = (this.radius * 2 + 6) * 0.9;
                    if (isHighQuality) { ctx.shadowBlur = 15; ctx.shadowColor = "white"; }
                    ctx.stroke();
                    ctx.restore();
                }

                // Main Body Color
                ctx.strokeStyle = this.skinColor;
                ctx.lineWidth = this.radius * 2;
                ctx.stroke();

                // Head
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.drawImage(this.headSprite, -this.headSprite.width/2, -this.headSprite.height/2);
                
                // Eyes
                this._drawEyes(ctx, isHighQuality);
                ctx.restore();
            }

            _drawEyes(ctx, isHighQuality) {
                const drawSide = (side) => {
                    const eyeX = this.radius * 0.4;
                    const eyeY = (side === 'left' ? -1 : 1) * (this.radius * 0.55);
                    const eyeRadius = this.radius * 0.42;

                    ctx.save();
                    ctx.translate(eyeX, eyeY);

                    // Simplified Eyes for Low Quality
                    if (!isHighQuality) {
                         ctx.fillStyle = '#f0f0f0';
                         ctx.beginPath(); ctx.arc(0, 0, eyeRadius, 0, Math.PI*2); ctx.fill();
                         ctx.fillStyle = "#111"; 
                         ctx.beginPath(); ctx.arc(eyeRadius*0.2, 0, eyeRadius*0.6, 0, Math.PI*2); ctx.fill();
                         ctx.fillStyle = "rgba(255,255,255,0.9)";
                         ctx.beginPath(); ctx.arc(eyeRadius*0.2 - eyeRadius*0.18, -eyeRadius*0.18, eyeRadius*0.15, 0, Math.PI*2); ctx.fill();
                         ctx.restore();
                         return;
                    }

                    // Dynamic Eyes for High Quality
                    const blinkScale = this.eyeOpenness;
                    
                    // Closed Eye line
                    if (blinkScale < 0.1) {
                        ctx.beginPath(); ctx.moveTo(-eyeRadius, 0); ctx.lineTo(eyeRadius, 0);
                        ctx.lineWidth = 1.5; ctx.strokeStyle = "#333"; ctx.stroke();
                        ctx.restore(); return;
                    }

                    ctx.scale(1, blinkScale);
                    const scleraGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, eyeRadius);
                    scleraGrad.addColorStop(0, '#ffffff'); scleraGrad.addColorStop(1, '#e6e6e6');
                    ctx.fillStyle = scleraGrad;
                    ctx.beginPath(); ctx.arc(0, 0, eyeRadius, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = "rgba(0,0,0,0.15)"; ctx.lineWidth = 0.5; ctx.stroke();

                    const pupilSize = eyeRadius * 0.55;
                    const pupilRange = eyeRadius * (0.3 + (0.15 * (Math.abs(this.lookAngle)/(Math.PI/2.2))));
                    const pDx = Math.cos(this.lookAngle) * pupilRange;
                    const pDy = Math.sin(this.lookAngle) * pupilRange;

                    ctx.fillStyle = "#111"; 
                    ctx.beginPath(); ctx.arc(pDx, pDy, pupilSize, 0, Math.PI*2); ctx.fill();

                    if (this.eyeOpenness > 0.4) {
                        ctx.fillStyle = "rgba(255,255,255,0.9)";
                        ctx.beginPath(); ctx.arc(pDx - pupilSize*0.3, pDy - pupilSize*0.3, pupilSize*0.25, 0, Math.PI*2); ctx.fill();
                    }
                    ctx.restore();
                };
                drawSide('left');
                drawSide('right');
            }
        }

        /**
         * ==========================================
         * MODULE 5: CORE ENGINE
         * ==========================================
         * Ties all modules together: Init, Loop, Render logic.
         */
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.renderer = new RenderEngine(this.canvas);
                this.input = new InputManager(this.canvas);
                this.player = new Snake();
                
                // System State
                this.isRunning = false;
                this.lastTime = 0;
                this.gameZoom = 1;
                this.camera = { x: 0, y: 0 };
                this.worldRadius = Config.Game.worldRadius;
                
                this.initUI();
            }

            initUI() {
                // Setup Menu Buttons
                const btnMobile = document.getElementById('btn-mode-mobile');
                const btnDesktop = document.getElementById('btn-mode-desktop');
                const menu = document.getElementById('main-menu-overlay');

                const startGame = (mode) => {
                    menu.style.display = 'none';
                    this.input.setMode(mode);
                    this.renderer.setQuality(mode === 'desktop');
                    
                    if(mode === 'desktop') document.getElementById('ui-desktop').style.display = 'block';
                    else {
                        document.getElementById('hint-move').style.display = 'block';
                        document.getElementById('hint-boost').style.display = 'block';
                    }

                    this.start();
                };

                btnMobile.onclick = () => startGame('mobile');
                btnDesktop.onclick = () => startGame('desktop');
                
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize(); // Initial sizing
            }

            handleResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                this.renderer.resize(w, h);
                
                // Calculate zoom to keep consistent view area
                const currentArea = w * h;
                this.gameZoom = Math.sqrt(currentArea / Config.Game.targetVisibleArea);
                this.gameZoom = Utils.clamp(this.gameZoom, 0.1, 20.0);
            }

            start() {
                if(this.isRunning) return;
                this.isRunning = true;
                requestAnimationFrame((t) => this.loop(t));
            }

            loop(timestamp) {
                if (!this.lastTime) this.lastTime = timestamp;
                let deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                if (deltaTime > 100) deltaTime = 100; // Cap lag
                const timeScale = deltaTime / 16.667;

                this.update(timeScale, timestamp);
                this.draw(timestamp);

                requestAnimationFrame((t) => this.loop(t));
            }

            update(timeScale, timestamp) {
                // World Pulse Effect
                const pulse = Math.sin(timestamp * 0.002); 
                this.worldRadius = Config.Game.worldRadius + (pulse * 40); 

                // Update Player
                const inputState = this.input.getInputState();
                this.player.update(timeScale, inputState, this.worldRadius, this.renderer.highQuality);

                // Update Camera
                const viewW = this.renderer.width / this.gameZoom;
                const viewH = this.renderer.height / this.gameZoom;
                this.camera.x = this.player.x - viewW / 2;
                this.camera.y = this.player.y - viewH / 2;
            }

            draw(timestamp) {
                this.renderer.clear();
                const ctx = this.renderer.ctx;

                // 1. GAME WORLD TRANSFORM
                ctx.save();
                ctx.scale(this.gameZoom, this.gameZoom);
                ctx.translate(-this.camera.x, -this.camera.y);

                // 2. BACKGROUND
                this.drawBackground(ctx, timestamp);

                // 3. WORLD BOUNDARY
                this.drawBoundary(ctx, timestamp);

                // 4. ENTITIES
                this.player.draw(ctx, this.renderer.highQuality);

                ctx.restore();

                // 5. UI / OVERLAYS (No transform)
                if (this.renderer.highQuality && this.renderer.cache.vignette) {
                    ctx.drawImage(this.renderer.cache.vignette, 0, 0);
                }
                this.drawMinimap(ctx);
            }

            drawBackground(ctx, timestamp) {
                const camX = this.camera.x;
                const camY = this.camera.y;
                const vw = this.renderer.width / this.gameZoom;
                const vh = this.renderer.height / this.gameZoom;

                // Fill black base
                ctx.fillStyle = '#000000';
                ctx.fillRect(camX, camY, vw, vh);

                const r = Config.Background.hexSize;
                const xStep = 1.5 * r;
                const yStep = Math.sqrt(3) * r;
                
                const startCol = Math.floor(camX / xStep) - 1;
                const startRow = Math.floor(camY / yStep) - 1;
                const cols = Math.ceil(vw / xStep) + 2;
                const rows = Math.ceil(vh / yStep) + 2;

                const useCache = !this.renderer.highQuality && this.renderer.cache.mobileHex;
                const drawR = Math.max(0, r - (Config.Background.hexGap / 2));

                for (let c = startCol; c < startCol + cols; c++) {
                    for (let rw = startRow; rw < startRow + rows; rw++) {
                        let hx = c * xStep;
                        let hy = rw * yStep;
                        if (c % 2 !== 0) hy += yStep / 2;

                        if (useCache) {
                            // Blit optimized image
                            const img = this.renderer.cache.mobileHex;
                            ctx.drawImage(img, hx - img.width/2, hy - img.height/2);
                        } else {
                            // Draw high quality animated hex
                            const phase = Math.abs(Utils.getPseudoRandom(c, rw) % (Math.PI*2));
                            const sinVal = Math.sin(timestamp * Config.Background.animSpeed + phase);
                            const norm = (sinVal + 1) / 2;
                            const l = Config.Background.centerMinL + (Config.Background.centerMaxL - Config.Background.centerMinL) * norm;
                            
                            const grad = ctx.createRadialGradient(hx, hy, 0, hx, hy, drawR);
                            grad.addColorStop(0, `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, ${l}%)`);
                            grad.addColorStop(1, `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, ${Config.Background.lightnessEdge}%)`);
                            
                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            const offsets = this.renderer.cache.hexOffsets;
                            for(let i=0; i<6; i++) {
                                if(i===0) ctx.moveTo(hx + offsets[i].x, hy + offsets[i].y);
                                else ctx.lineTo(hx + offsets[i].x, hy + offsets[i].y);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            }

            drawBoundary(ctx, timestamp) {
                const zoneThickness = 400; 
                const grad = ctx.createRadialGradient(0, 0, this.worldRadius, 0, 0, this.worldRadius + zoneThickness);
                grad.addColorStop(0, Config.Colors.boundary);
                grad.addColorStop(0.3, 'rgba(255, 0, 0, 0.2)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, this.worldRadius + zoneThickness, 0, Math.PI * 2); 
                ctx.arc(0, 0, this.worldRadius, 0, Math.PI * 2, true);           
                ctx.fill();

                const pulse = Math.sin(timestamp * 0.002);
                ctx.lineWidth = 4;
                ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 + pulse * 0.2})`;
                ctx.beginPath();
                ctx.arc(0, 0, this.worldRadius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = "rgba(255, 50, 50, 0.15)";
                ctx.font = "200px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("âœ•", 0, 0); 
            }

            drawMinimap(ctx) {
                const { radius, margin, playerColor } = Config.Minimap;
                const centerX = margin + radius;
                const centerY = margin + radius;

                // Draw Background from Cache
                if (this.renderer.cache.minimapBg) {
                    ctx.drawImage(this.renderer.cache.minimapBg, centerX - (radius+margin), centerY - (radius+margin));
                }

                // Draw Player Dot
                const normX = this.player.x / this.worldRadius;
                const normY = this.player.y / this.worldRadius;
                const dist = Math.hypot(normX, normY);
                let pX, pY;

                if (dist > 1) {
                    const a = Math.atan2(normY, normX);
                    pX = centerX + Math.cos(a) * radius;
                    pY = centerY + Math.sin(a) * radius;
                } else {
                    pX = centerX + normX * radius;
                    pY = centerY + normY * radius;
                }

                ctx.fillStyle = playerColor;
                ctx.beginPath();
                ctx.arc(pX, pY, 3.5, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // --- BOOTSTRAP ---
        window.onload = () => {
            const game = new GameEngine();
            // Global access for debugging if needed
            window.WormoneyGame = game;
        };

    </script>
</body>
</html>
