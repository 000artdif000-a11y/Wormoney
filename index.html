<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wormoney (Premium Dark UI)</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700;900&family=Exo+2:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        /* --- GLOBAL & RESET --- */
        :root {
            /* Ultra Deep Palette */
            --bg-deep: #000000;
            --bg-overlay: radial-gradient(circle at 50% 30%, #0f1116 0%, #000000 90%);
            
            /* Wet Glass Effect */
            --card-glass: #050505; 
            
            /* Columns */
            --col-bg: rgba(10, 10, 12, 0.6);
            --col-border: 1px solid rgba(255, 255, 255, 0.04);

            --item-bg: rgba(0, 0, 0, 0.7);
            --stroke: rgba(255, 255, 255, 0.06);
            --stroke-highlight: rgba(255, 255, 255, 0.15);
            
            --text-main: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.5);
            --text-muted-2: rgba(255, 255, 255, 0.3);
            
            --accent-red: #ff3b3b;
            --accent-gold: #ffcc00;
            --accent-green: #69f0ae;
            
            --font-main: 'Outfit', sans-serif;
            --font-mono: 'Exo 2', sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            background-color: var(--bg-deep);
            background-image: var(--bg-overlay);
            font-family: var(--font-main);
            color: white;
            user-select: none;
            cursor: crosshair;
            touch-action: none;
        }

        /* --- ANIMATIONS --- */
        @keyframes fadeInSlide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(-15px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes pulseGlow {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }
        @keyframes textShine {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        /* --- FORCE LANDSCAPE ON MOBILE --- */
        /* This logic rotates the entire body 90deg on portrait phones */
        @media screen and (orientation: portrait) and (max-width: 900px) {
            body {
                position: fixed; top: 0; left: 0;
                width: 100vh; height: 100vw;
                transform: rotate(90deg); transform-origin: top left;
                left: 100%; 
            }
            #game-canvas, #main-menu-overlay, .ui-layer { width: 100vh; height: 100vw; }
        }

        #game-canvas { display: block; width: 100%; height: 100%; z-index: 1; }

        /* --- UI OVERLAYS (HUD) --- */
        .ui-layer { position: absolute; pointer-events: none; z-index: 10; }

        .ui-info, .ui-stats {
            bottom: 2vmin; 
            background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(12px);
            border: 1px solid var(--stroke); color: #ccc;
            font-size: max(10px, 1.3vmin); letter-spacing: 0.5px;
            padding: 0.8vmin 1.5vmin; border-radius: 0.8vmin;
            text-transform: uppercase; font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.8);
            display: none;
        }
        .ui-info { left: 2vmin; border-left: 3px solid var(--accent-red); }
        .ui-stats { right: 2vmin; border-right: 3px solid var(--accent-gold); text-align: right; flex-direction: column; gap: 0.4vmin; }

        .stat-row { display: flex; justify-content: flex-end; gap: 1vmin; }
        .stat-label { color: var(--text-muted); font-size: max(9px, 1.1vmin); }
        .stat-value { color: #fff; font-weight: 700; }

        .ui-leaderboard {
            top: 2vmin; right: 2vmin; 
            width: max(160px, 15vw);
            background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(16px);
            border: 1px solid var(--stroke); border-radius: 1.2vmin;
            padding: 1.5vmin; box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            display: none;
        }
        
        .lb-header {
            font-size: max(10px, 1.2vmin); font-weight: 800; text-transform: uppercase; letter-spacing: 2px;
            color: var(--text-muted); border-bottom: 1px solid var(--stroke); padding-bottom: 0.8vmin; margin-bottom: 0.8vmin; text-align: right;
        }
        .lb-list { list-style: none; padding: 0; margin: 0; }
        .lb-item {
            display: flex; justify-content: space-between; font-size: max(11px, 1.3vmin); margin-bottom: 0.5vmin;
            padding: 0.5vmin 1vmin; border-radius: 0.6vmin; transition: all 0.3s;
        }
        .lb-item.is-me {
            background: linear-gradient(90deg, rgba(255, 59, 59, 0.1), rgba(255, 59, 59, 0.2));
            border-right: 3px solid var(--accent-red);
            color: #fff; text-shadow: 0 0 10px rgba(255, 59, 59, 0.5);
        }
        .lb-rank { color: var(--text-muted); font-weight: 700; width: 2.5vmin; }
        .lb-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 1vmin; text-align: right; font-weight: 500; }
        .lb-score { color: var(--accent-gold); font-weight: 700; }

        .ui-cashout-hint {
            bottom: 3vmin; left: 50%; transform: translateX(-50%);
            padding: 1vmin 2vmin; 
            background: linear-gradient(to top, rgba(255, 204, 0, 0.1), rgba(0,0,0,0.95));
            border-bottom: 2px solid var(--accent-gold); backdrop-filter: blur(8px);
            font-size: max(12px, 1.4vmin); font-weight: 700; color: #fff;
            border-radius: 1.2vmin 1.2vmin 0 0;
            display: flex; align-items: center; gap: 1vmin;
            text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
            transition: opacity 0.2s; display: none;
        }
        .ui-cashout-hint .key-badge {
            background: var(--accent-gold); color: #000; padding: 0.2vmin 0.8vmin; border-radius: 0.4vmin; font-size: max(10px, 1.1vmin); font-weight: 900;
        }

        #mobile-cashout-btn {
            position: absolute; bottom: 80px; right: 20px; width: 72px; height: 72px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #2a2a30, #000);
            border: 2px solid rgba(255, 204, 0, 0.3);
            color: var(--accent-gold); display: none; justify-content: center; align-items: center; flex-direction: column;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6); z-index: 60; pointer-events: auto;
            transition: transform 0.1s;
        }
        #mobile-cashout-btn:active { transform: scale(0.92); border-color: var(--accent-gold); box-shadow: 0 0 20px rgba(255, 204, 0, 0.4); }
        #mobile-cashout-btn span.icon { font-size: 28px; font-weight: 900; line-height: 1; }
        #mobile-cashout-btn span.label { font-size: 9px; font-weight: 700; text-transform: uppercase; opacity: 0.8; }

        .tutorial-hint {
            top: 20%; width: 100%; left: 0; text-align: center; color: rgba(255,255,255,0.3);
            font-size: 13px; font-weight: 700; text-transform: uppercase; letter-spacing: 3px;
            pointer-events: none; display: none;
        }

        #joystick-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        #joystick-base {
            position: absolute; width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px); display: none; transform: translate(-50%, -50%);
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #666, #222);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); transform: translate(-50%, -50%);
        }

        /* --- MAIN MENU STYLES (UPDATED FOR ADAPTIVITY) --- */
        #main-menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.4);
            opacity: 1; transition: opacity 0.6s ease;
        }
        
        #main-menu-overlay::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(var(--stroke) 1px, transparent 1px),
                              linear-gradient(90deg, var(--stroke) 1px, transparent 1px);
            background-size: 60px 60px;
            mask-image: radial-gradient(circle at center, black 10%, transparent 80%);
            z-index: -1; opacity: 0.15; pointer-events: none;
        }

        .menu-card {
            /* ADAPTIVE SIZE: Replaced fixed/min dimensions with relative units */
            width: 95vw; 
            height: 90vh; 
            max-width: 1600px; 
            max-height: 900px; 
            
            /* Reduced min-constraints significantly for mobile landscape support */
            min-height: 320px; 
            min-width: 600px;

            display: flex; 
            background: var(--card-glass);
            backdrop-filter: blur(60px); -webkit-backdrop-filter: blur(60px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 24px;
            box-shadow: 0 0 100px rgba(0,0,0,1), inset 0 1px 0 rgba(255,255,255,0.08);
            overflow: hidden; 
            animation: menuEntry 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .menu-card.exiting { animation: menuExit 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

        @keyframes menuEntry { from { opacity: 0; transform: scale(0.95) translateY(20px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        @keyframes menuExit { 0% { opacity: 1; transform: scale(1); filter: blur(0px); } 100% { opacity: 0; transform: scale(1.15); filter: blur(15px); } }

        .menu-col { 
            padding: 3vh 2vw; display: flex; flex-direction: column; gap: 2vh; 
            box-sizing: border-box; position: relative; 
        }

        .menu-left { 
            flex: 1.4; background: var(--col-bg); 
            border-right: var(--col-border);
            box-shadow: inset -20px 0 40px rgba(0,0,0,0.5);
        }
        
        .menu-right { 
            flex: 1.4; background: var(--col-bg); 
            border-left: var(--col-border);
            box-shadow: inset 20px 0 40px rgba(0,0,0,0.5);
            gap: 1vh; overflow-y: auto; scrollbar-width: none;
        }
        .menu-right::-webkit-scrollbar { display: none; }

        .menu-center { 
            flex: 2.1; 
            /* Reduced from 380px to allow fitting on phones */
            min-width: 260px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2; 
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.4) 100%);
        }

        /* FIX 1: Clipping Issue */
        .menu-lb-title { 
            font-size: 11px; font-weight: 800; text-transform: uppercase; 
            color: var(--text-muted); letter-spacing: 2px; 
            margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; 
            padding-top: 6px; padding-bottom: 2px; min-height: 24px;
        }
        
        .lb-tabs { 
            display: flex; gap: 4px; margin-bottom: 10px; 
            background: rgba(0,0,0,0.5); padding: 4px; border-radius: 8px; border: 1px solid var(--stroke);
        }
        .lb-tab { 
            flex: 1; background: transparent; border: none; color: var(--text-muted); 
            padding: 6px 0; font-size: 9px; font-weight: 700; text-transform: uppercase; 
            cursor: pointer; border-radius: 6px; transition: all 0.2s; text-align: center; 
        }
        .lb-tab:hover { color: #fff; background: rgba(255,255,255,0.05); transform: translateY(-1px); }
        .lb-tab.active { 
            background: rgba(255, 255, 255, 0.06); color: #fff; 
            border: 1px solid rgba(255,255,255,0.05);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); transform: translateY(0);
        }
        
        /* FIX 3: Animations */
        .menu-lb-list { 
            display: flex; flex-direction: column; gap: 6px; 
            overflow-y: auto; overflow-x: hidden; flex: 1; padding: 10px;
            background: rgba(0, 0, 0, 0.4); border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.02);
            box-shadow: inset 0 2px 15px rgba(0,0,0,0.5);
            scrollbar-width: none; -ms-overflow-style: none; 
        }
        .menu-lb-list::-webkit-scrollbar { display: none; }
        
        .glb-row { 
            display: flex; justify-content: space-between; align-items: center; 
            font-size: 13px; color: var(--text-muted); padding: 12px; 
            background: rgba(0,0,0,0.6); 
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 8px; transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            opacity: 0; animation: slideInRight 0.4s ease-out forwards;
        }
        .glb-row:nth-child(1) { animation-delay: 0.05s; }
        .glb-row:nth-child(2) { animation-delay: 0.1s; }
        .glb-row:nth-child(3) { animation-delay: 0.15s; }
        .glb-row:nth-child(4) { animation-delay: 0.2s; }
        .glb-row:nth-child(5) { animation-delay: 0.25s; }

        .glb-row:hover { 
            background: rgba(30, 30, 35, 0.8); color: #fff; 
            transform: translateX(4px) scale(1.01); 
            border-color: rgba(255,255,255,0.15);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .glb-name { color: var(--text-main); font-weight: 600; }
        .glb-val { color: var(--accent-gold); font-weight: 700; text-shadow: 0 0 15px rgba(255, 204, 0, 0.15); font-family: var(--font-mono); }

        /* FIX 2: Title Spacing */
        .game-title { 
            text-align: center; margin-bottom: 2vh; 
            margin-top: 5vh; 
            position: relative; width: 100%; 
        }
        .game-title h1 {
            font-family: var(--font-main); font-size: clamp(24px, 5.5vh, 60px); /* More aggressive clamp */
            font-weight: 900; margin: 0; letter-spacing: -2px;
            background: linear-gradient(90deg, #FFD700 0%, #FF8C00 25%, #FF4500 50%, #FF8C00 75%, #FFD700 100%);
            background-size: 300% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 35px rgba(255, 140, 0, 0.4)); animation: textShine 4s linear infinite;
        }
        .game-title::after { 
            content: 'BETA'; position: absolute; top: 0; right: 20%; 
            background: var(--accent-red); color: white; font-size: 10px; padding: 2px 6px; 
            border-radius: 4px; font-weight: 700; letter-spacing: 1px; transform: rotate(10deg); 
            box-shadow: 0 2px 10px rgba(255,59,59,0.5); 
        }

        .preview-container {
            width: 100%; flex: 1; min-height: 120px; /* Reduced min height */
            background: radial-gradient(circle at center, #0f1115 0%, #000000 90%);
            border-radius: 16px; 
            box-shadow: inset 0 0 50px rgba(0,0,0,1), 0 20px 40px rgba(0,0,0,0.8); 
            border: 1px solid rgba(255,255,255,0.05); margin-bottom: 2vh; position: relative; overflow: hidden;
        }
        .preview-container::after { 
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.4) 51%); 
            background-size: 100% 4px; pointer-events: none; opacity: 0.15; 
        }
        #skin-preview { width: 100%; height: 100%; object-fit: cover; }

        .center-controls { width: 100%; max-width: 380px; display: flex; flex-direction: column; gap: 1.2vh; }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        
        /* FIX 5: Subtle Nickname Border */
        #nickname-input { 
            width: 100%; background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255,255,255,0.05); 
            border-bottom: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px; padding: 14px 0; 
            color: #fff; font-family: var(--font-main); font-size: 18px; font-weight: 600; 
            text-align: center; transition: all 0.3s;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.3);
        }
        #nickname-input:focus { 
            background: rgba(0,0,0,0.7); border-color: rgba(255,255,255,0.3); outline: none; 
            box-shadow: 0 0 15px rgba(255,255,255,0.1), inset 0 2px 6px rgba(0,0,0,0.5);
        }
        #nickname-input::placeholder { color: var(--text-muted-2); text-transform: uppercase; font-size: 12px; letter-spacing: 2px; }

        .color-picker { display: flex; justify-content: center; gap: 10px; padding: 2px 0; flex-wrap: wrap; }
        .color-swatch { 
            width: 28px; height: 28px; border-radius: 50%; cursor: pointer; 
            border: 2px solid var(--stroke); transition: all 0.3s cubic-bezier(0.3, 1.5, 0.5, 1); 
            position: relative; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .color-swatch:hover { transform: scale(1.2); z-index: 10; border-color: #fff; }
        .color-swatch:active { transform: scale(0.9); }
        .color-swatch.active { transform: scale(1.3); border-color: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.4); }

        /* FIX: Juicy Lobby Buttons */
        .lobby-selector { 
            display: flex; justify-content: space-between; 
            background: rgba(0,0,0,0.6); padding: 5px; border-radius: 12px; 
            border: 1px solid var(--stroke);
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.8);
            gap: 6px;
        }
        .lobby-btn { 
            flex: 1; background: transparent; border: 1px solid transparent; 
            color: var(--text-muted); padding: 12px 0; font-size: 11px; font-weight: 800; text-transform: uppercase; 
            cursor: pointer; border-radius: 8px; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); 
            font-family: var(--font-mono); position: relative; overflow: hidden;
        }
        .lobby-btn:hover { color: #fff; background: rgba(255,255,255,0.03); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        .lobby-btn:active { transform: translateY(0) scale(0.96); }
        
        .lobby-btn.active { 
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.05) 0%, rgba(255, 140, 0, 0.1) 100%);
            border: 1px solid rgba(255, 215, 0, 0.6); color: #FFD700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.15), inset 0 0 10px rgba(255, 215, 0, 0.05);
            transform: translateY(0);
        }
        .lobby-btn.active::after {
            content: ''; position: absolute; bottom: 0; left: 30%; right: 30%; height: 2px;
            background: #FFD700; box-shadow: 0 0 10px #FFD700; border-radius: 2px 2px 0 0;
        }

        .lobby-stats-row { display: flex; width: 100%; margin-top: 8px; padding: 0 4px; }
        .l-stat { 
            flex: 1; display: flex; justify-content: center; align-items: center; gap: 6px; 
            font-size: 10px; font-weight: 700; color: #4ade80; /* Juicy Green */
            text-transform: uppercase; letter-spacing: 1px; 
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.4); cursor: default; 
        }
        .l-dot { width: 6px; height: 6px; background: #4ade80; border-radius: 50%; box-shadow: 0 0 8px #4ade80; animation: pulseGlow 2s infinite; }

        /* FIX: Shine Button */
        #btn-play { 
            width: 100%; margin-top: 10px; 
            background: linear-gradient(135deg, #e01b1b, #990000); 
            border: none; padding: 20px; border-radius: 14px; 
            color: #fff; font-family: var(--font-main); font-size: 18px; font-weight: 800; 
            text-transform: uppercase; letter-spacing: 2px; cursor: pointer; 
            box-shadow: 0 10px 30px rgba(200, 0, 0, 0.3), inset 0 1px 0 rgba(255,255,255,0.2); 
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); border: 1px solid rgba(0,0,0,0.2);
            position: relative; overflow: hidden;
        }
        #btn-play:hover { transform: translateY(-3px) scale(1.01); box-shadow: 0 20px 50px rgba(200, 0, 0, 0.5), inset 0 1px 0 rgba(255,255,255,0.4); filter: brightness(1.1); }
        #btn-play:active { transform: translateY(1px) scale(0.98); box-shadow: 0 5px 15px rgba(204, 0, 0, 0.3); }
        #btn-play::after {
            content: ''; position: absolute; top: 0; left: 0; width: 60%; height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.4), transparent);
            transform: skewX(-20deg) translateX(-150%); transition: transform 0s;
        }
        #btn-play:hover::after { transform: skewX(-20deg) translateX(250%); transition: transform 0.6s ease-in-out; }

        /* FIX 4: Compact Commission */
        .commission-info-block {
            text-align: center; margin-top: 15px; /* Spaced */
            display: flex; flex-direction: column; gap: 1px; padding-bottom: 5px;
        }
        .commission-main {
            color: #fff59d; /* Yellow */
            font-size: 10px; font-weight: 600; letter-spacing: 0.5px; opacity: 0.9;
        }

        .balance-card { 
            background: linear-gradient(160deg, rgba(255,255,255,0.02), rgba(0,0,0,0.5)); 
            padding: 24px; border-radius: 18px; border: 1px solid var(--stroke); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center; margin-bottom: 10px; position: relative; overflow: hidden;
            transition: transform 0.3s ease;
        }
        .balance-card:hover { transform: translateY(-2px); box-shadow: 0 15px 40px rgba(0,0,0,0.6); }
        .balance-card::before {
            content:''; position: absolute; top:0; left:0; width:100%; height:100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.03), transparent);
            transform: skewX(-20deg) translateX(-150%); animation: shineMove 6s infinite; pointer-events: none;
        }

        .balance-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 2px; font-weight: 700; display: block; margin-bottom: 5px; }
        .balance-val { font-size: 32px; color: #fff; font-weight: 800; letter-spacing: -1px; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        .balance-val span { color: var(--accent-gold); font-size: 20px; margin-right: 2px; vertical-align: super; }

        .bank-actions { display: flex; gap: 8px; margin-top: 15px; }
        .bank-btn { 
            flex: 1; background: rgba(0,0,0,0.6); border: 1px solid var(--stroke); 
            color: var(--text-muted); padding: 10px; border-radius: 8px; 
            cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; 
            transition: all 0.2s; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .bank-btn:hover { background: rgba(255,255,255,0.05); color: #fff; border-color: var(--stroke-highlight); transform: translateY(-1px); }
        .bank-btn:active { transform: translateY(0) scale(0.96); }
        .bank-btn.deposit { color: var(--accent-green); border-color: rgba(105, 240, 174, 0.15); }
        .bank-btn.withdraw { color: var(--accent-gold); border-color: rgba(255, 204, 0, 0.15); }

        .settings-header { 
            font-size: 10px; font-weight: 800; color: var(--text-muted); 
            text-transform: uppercase; letter-spacing: 2px; margin-top: 10px; 
            margin-bottom: 6px; border-bottom: 1px solid var(--stroke); padding-bottom: 6px; 
        }
        
        .pill-toggle { 
            display: flex; background: rgba(0,0,0,0.6); border-radius: 10px; padding: 4px; 
            border: 1px solid var(--stroke); margin-bottom: 6px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .pill-btn { 
            flex: 1; background: transparent; border: none; color: var(--text-muted); 
            padding: 6px 0; font-size: 10px; font-weight: 700; text-transform: uppercase; 
            cursor: pointer; border-radius: 8px; transition: all 0.2s; letter-spacing: 0.5px;
        }
        .pill-btn:hover { background: rgba(255,255,255,0.03); color: #eee; }
        .pill-btn:active { transform: scale(0.95); }
        .pill-btn.active { background: rgba(255,255,255,0.06); color: #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.05); }
        .pill-btn[data-val="high"].active, .pill-btn[data-val="custom"].active, .pill-btn[data-val="on"].active { 
            background: rgba(76, 175, 80, 0.1); color: #81c784; border: 1px solid rgba(76, 175, 80, 0.3); 
        }
        .pill-btn[data-val="auto"].active, .pill-btn[data-val="off"].active { 
            background: rgba(33, 150, 243, 0.1); color: #64b5f6; border: 1px solid rgba(33, 150, 243, 0.3); 
        }
        .stat-label-small { font-size: 9px; color: var(--text-muted); margin-bottom: 3px; margin-left: 2px; display: block; font-weight: 600; }

        .slider-wrapper { margin-bottom: 8px; padding: 0 5px; overflow: hidden; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); max-height: 50px; opacity: 1; transform: translateY(0); }
        .slider-wrapper.hidden { max-height: 0; opacity: 0; margin: 0; pointer-events: none; transform: translateY(-5px); }
        
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 5px 0; cursor: pointer; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255, 255, 255, 0.15); border-radius: 2px; transition: background 0.2s; }
        input[type=range]:hover::-webkit-slider-runnable-track { background: rgba(255,255,255,0.25); }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent-gold); margin-top: -5px; box-shadow: 0 0 10px rgba(255, 204, 0, 0.6); cursor: pointer; transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 0 15px rgba(255, 204, 0, 0.8); }

        /* --- ADAPTIVE MEDIA QUERIES --- */
        
        /* Compact layout for screens narrower than 1000px (or landscape mobile) */
        @media screen and (max-width: 1000px) {
            .menu-col { padding: 2vh 1.5vw; gap: 1vh; }
            .menu-card { width: 98vw; height: 95vh; border-radius: 16px; }
            .game-title h1 { font-size: 4vh; }
            .game-title { margin-top: 2vh; margin-bottom: 1vh; }
            .glb-row { padding: 8px; font-size: 11px; }
            #btn-play { padding: 15px; font-size: 16px; }
            .balance-card { padding: 15px; }
            .balance-val { font-size: 24px; }
            .bank-btn { padding: 8px; }
        }

        /* Highly compressed vertical layout (landscape phones) */
        @media screen and (max-height: 600px) {
            .game-title h1 { font-size: 3vh; }
            .menu-col { padding: 10px; gap: 8px; }
            .preview-container { min-height: 80px; margin-bottom: 1vh; }
            #nickname-input { padding: 8px 0; font-size: 14px; }
            .color-swatch { width: 22px; height: 22px; }
            #btn-play { padding: 12px; margin-top: 5px; font-size: 14px; }
            .commission-info-block { margin-top: 5px; }
            .balance-card { padding: 12px; margin-bottom: 5px; }
            .balance-val { font-size: 18px; }
            .bank-actions { margin-top: 8px; }
            .pill-toggle { padding: 2px; margin-bottom: 4px; }
            .pill-btn { padding: 4px 0; font-size: 9px; }
            .settings-header { margin-top: 5px; padding-bottom: 4px; margin-bottom: 4px; }
            
            /* Hide non-essential labels in very tight vertical spaces */
            .stat-label-small { display: none; }
        }
    </style>
</head>
<body>

    <!-- GAME CANVAS -->
    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER: DESKTOP LEFT -->
    <div id="ui-desktop" class="ui-layer ui-info">
        <span id="txt-controls">CONTROLS:</span> <span id="txt-mouse-move">Mouse to Move</span> &bull; <span id="txt-hold-boost">Hold Click to Boost</span>
    </div>

    <!-- UI LAYER: LEADERBOARD -->
    <div id="ui-leaderboard" class="ui-layer ui-leaderboard">
        <div class="lb-header" id="txt-hud-lb">Leaderboard</div>
        <ul class="lb-list" id="lb-list"></ul>
    </div>

    <!-- UI LAYER: STATS -->
    <div id="ui-stats" class="ui-layer ui-stats">
        <div class="stat-row">
            <span class="stat-label">FPS</span>
            <span class="stat-value" id="stat-fps">60</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">TICK</span>
            <span class="stat-value" id="stat-ping">60Hz</span>
        </div>
    </div>

    <!-- UI LAYER: CASH OUT -->
    <div id="ui-cashout" class="ui-layer ui-cashout-hint">
        <span id="txt-cash-out">Cash Out</span>
        <span class="key-badge">Hold Q</span>
        <span>3s</span>
    </div>
    
    <!-- UI LAYER: MOBILE CASH OUT BUTTON -->
    <div id="mobile-cashout-btn">
        <span class="icon">$</span>
        <span class="label" id="txt-cash-out-mob">Cash Out</span>
    </div>

    <!-- UI LAYER: MOBILE / JOYSTICK -->
    <div id="joystick-ui">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
        <div class="ui-layer tutorial-hint" style="top: 80%;" id="mobile-hint">
            <span style="display:inline-block; margin: 0 20px;">LEFT SIDE<br><span style="font-size:11px; color:#889; font-weight:400" id="txt-touch-move">TOUCH & DRAG TO STEER</span></span>
            <span style="display:inline-block; margin: 0 20px;">RIGHT SIDE<br><span style="font-size:11px; color:#889; font-weight:400" id="txt-hold-boost-mob">HOLD TO BOOST</span></span>
        </div>
    </div>

    <!-- MAIN MENU OVERLAY -->
    <div id="main-menu-overlay">
        <div class="menu-card">
            <!-- LEFT COLUMN -->
            <div class="menu-col menu-left">
                <div class="menu-lb-title">
                    <span id="txt-top-winners">Top Winners</span>
                    <span id="txt-live" style="color: var(--accent-red); font-size: 9px;">LIVE</span>
                </div>
                <div class="lb-tabs" id="lb-tabs">
                    <button class="lb-tab active" data-type="daily" id="txt-daily">Daily</button>
                    <button class="lb-tab" data-type="week" id="txt-week">Week</button>
                    <button class="lb-tab" data-type="month" id="txt-month">Month</button>
                    <button class="lb-tab" data-type="global" id="txt-global">Global</button>
                </div>
                <div class="menu-lb-list">
                    <div class="glb-row"><span class="glb-name">CryptoKing</span><span class="glb-val">+$4,290</span></div>
                    <div class="glb-row"><span class="glb-name">Satoshi_Snake</span><span class="glb-val">+$1,850</span></div>
                    <div class="glb-row"><span class="glb-name">ElonMusk_Real</span><span class="glb-val">+$920</span></div>
                    <div class="glb-row"><span class="glb-name">Doge_To_Moon</span><span class="glb-val">+$550</span></div>
                    <div class="glb-row"><span class="glb-name">Whale_Alert</span><span class="glb-val">+$300</span></div>
                </div>
            </div>

            <!-- CENTER COLUMN -->
            <div class="menu-col menu-center">
                <div class="game-title"><h1>WORMONEY</h1></div>
                <div class="preview-container"><canvas id="skin-preview"></canvas></div>
                <div class="center-controls">
                    <div class="input-group"><input type="text" id="nickname-input" placeholder="NICKNAME" maxlength="12" autocomplete="off" spellcheck="false"></div>
                    <div class="input-group"><div class="color-picker" id="color-picker"></div></div>
                    <div class="input-group">
                        <div class="lobby-selector" id="lobby-selector">
                            <button class="lobby-btn active" data-val="0" id="txt-free">Free</button>
                            <button class="lobby-btn" data-val="0.1">$0.1</button>
                            <button class="lobby-btn" data-val="1">$1</button>
                        </div>
                        <!-- NEW ONLINE STATS DISPLAY -->
                        <div class="lobby-stats-row">
                            <div class="l-stat"><span class="l-dot"></span>0 <span class="lbl-online">ONLINE</span></div>
                            <div class="l-stat"><span class="l-dot"></span>0 <span class="lbl-online">ONLINE</span></div>
                            <div class="l-stat"><span class="l-dot"></span>0 <span class="lbl-online">ONLINE</span></div>
                        </div>
                    </div>
                    <button id="btn-play">JOIN LOBBY</button>
                    
                    <!-- Fix: Commission Info (Yellow, No Example) -->
                    <div class="commission-info-block">
                        <div class="commission-main" id="txt-commission">10% commission on winnings</div>
                    </div>
                </div>
            </div>

            <!-- RIGHT COLUMN -->
            <div class="menu-col menu-right">
                <div class="balance-card">
                    <span class="balance-label" id="txt-balance">Available Balance</span>
                    <div class="balance-val"><span>$</span>124.50</div>
                    <div class="bank-actions">
                        <button class="bank-btn deposit" id="txt-deposit">Deposit</button>
                        <button class="bank-btn withdraw" id="txt-withdraw">Withdraw</button>
                    </div>
                </div>

                <div class="settings-header" id="txt-preferences">Preferences</div>
                <label class="stat-label-small" id="txt-graphics">Graphics Quality</label>
                <div class="pill-toggle" id="graphics-toggle">
                    <button class="pill-btn" data-val="low" id="txt-performance">Performance</button>
                    <button class="pill-btn active" data-val="high" id="txt-quality">Quality</button>
                </div>
                
                <label class="stat-label-small" id="txt-vsync">Frame Rate Limit</label>
                <div class="pill-toggle" id="vsync-toggle">
                    <button class="pill-btn active" data-val="auto">AUTO</button>
                    <button class="pill-btn" data-val="custom">CUSTOM</button>
                </div>

                <div id="fps-slider-wrapper" class="slider-wrapper hidden">
                    <label class="stat-label-small" style="display:flex; justify-content:space-between;">
                        <span id="txt-fps-limit">Target FPS</span> 
                        <span id="fps-value" style="color:var(--accent-gold); font-weight:700;">60</span>
                    </label>
                    <input type="range" id="fps-slider" min="0" max="8" step="1" value="1">
                </div>

                <label class="stat-label-small" id="txt-input">Input Method</label>
                <div class="pill-toggle" id="device-toggle">
                    <button class="pill-btn" data-val="mobile" id="txt-touch">Touch</button>
                    <button class="pill-btn active" data-val="desktop" id="txt-mouse">Mouse</button>
                </div>

                <label class="stat-label-small" id="txt-language">Language</label>
                <div class="pill-toggle" id="lang-toggle">
                    <button class="pill-btn active" data-val="en">ENG</button>
                    <button class="pill-btn" data-val="ru">RUS</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * =================================================================================
         * SHARED CONFIG (Server & Client)
         * =================================================================================
         */
        const Config = {
            Game: { 
                tickRate: 60,
                tickTime: 1000 / 60,
                worldRadius: 1333,
                baseSpeed: 2.5, 
                boostSpeed: 5.5, 
                turnSpeed: 0.06,
                pathGap: 1.25, 
                initialSnakeLength: 30, 
                baseSnakeRadius: 11,
                targetVisibleArea: 400000
            },
            Food: { 
                count: 10, 
                spawnInterval: 700,
                glowStrength: 10
            },
            Skins: [
                { id: 'blue', primary: '#297afb', secondary: '#1c52b0', highlight: '#6eb6ff' },
                { id: 'red', primary: '#ff4444', secondary: '#aa2222', highlight: '#ff8888' },
                { id: 'green', primary: '#44ff44', secondary: '#22aa22', highlight: '#88ff88' },
                { id: 'purple', primary: '#d044ff', secondary: '#8822aa', highlight: '#e088ff' },
                { id: 'orange', primary: '#ffaa44', secondary: '#aa6622', highlight: '#ffcc88' },
                { id: 'cyan', primary: '#44ffff', secondary: '#22aaaa', highlight: '#aaffff' },
                { id: 'ruby', primary: '#e0115f', secondary: '#8a0b3c', highlight: '#ff5599' }
            ],
            Minimap: { radius: 80, margin: 15, bgCenter: 'rgba(15, 15, 25, 0.6)', bgEdge: 'rgba(5, 5, 10, 0.8)', borderColor: 'rgba(255, 255, 255, 0.1)', playerColor: '#fff' },
            Background: { hexSize: 24, hexGap: 4, hue: 220, saturation: 25, lightnessBase: 5, lightnessPulse: 9, animSpeed: 0.0015, cacheLevels: 20 }
        };

        const Translations = {
            en: {
                topWinners: "Top Winners", live: "LIVE", daily: "Daily", week: "Week", month: "Month", global: "Global",
                nickname: "NICKNAME", free: "Free", joinLobby: "JOIN LOBBY", commission: "10% commission on winnings",
                balance: "Available Balance", deposit: "Deposit", withdraw: "Withdraw", preferences: "Preferences",
                graphics: "Graphics", performance: "Performance", quality: "Quality", input: "Input Method", touch: "Touch", mouse: "Mouse",
                language: "Language", controls: "CONTROLS:", mouseMove: "Mouse to Move", holdBoost: "Hold Click to Boost",
                touchMove: "TOUCH & DRAG TO STEER", holdBoostMobile: "HOLD TO BOOST", cashOut: "Cash Out", hudLb: "Leaderboard",
                fpsLimit: "Target FPS", vsync: "Frame Rate", max: "UNLOCK", auto: "AUTO (V-SYNC)", custom: "CUSTOM",
                online: "ONLINE"
            },
            ru: {
                topWinners: "Топ Победителей", live: "ЛАЙВ", daily: "День", week: "Неделя", month: "Месяц", global: "Все",
                nickname: "НИКНЕЙМ", free: "Беспл.", joinLobby: "ИГРАТЬ", commission: "Комиссия с выигрыша 10%",
                balance: "Ваш Баланс", deposit: "Пополнить", withdraw: "Вывести", preferences: "Настройки",
                graphics: "Графика", performance: "Быстро", quality: "Красиво", input: "Управление", touch: "Тач", mouse: "Мышь",
                language: "Язык", controls: "УПРАВЛЕНИЕ:", mouseMove: "Мышь - Движение", holdBoost: "Клик - Ускорение",
                touchMove: "ТЯНИ ЧТОБЫ РУЛИТЬ", holdBoostMobile: "ЗАЖМИ ДЛЯ УСКОРЕНИЯ", cashOut: "Вывести", hudLb: "Лидерборд",
                fpsLimit: "Лимит FPS", vsync: "Частота кадров", max: "UNLOCK", auto: "АВТО", custom: "ВРУЧНУЮ",
                online: "ОНЛАЙН"
            }
        };

        // =================================================================================
        // OPTIMIZATION: Pre-computed lookup tables
        // =================================================================================
        const OPT = {
            sinLUT: new Float32Array(1024),
            PI2: Math.PI * 2,
            RAD_TO_IDX: 1024 / (Math.PI * 2),
            _foodQueryBuffer: [],
            _collisionQueryBuffer: [],
            _toRemoveBuffer: [],
            _snakesCache: [],
            
            init() {
                for (let i = 0; i < 1024; i++) {
                    this.sinLUT[i] = (Math.sin(i * this.PI2 / 1024) + 1) * 0.5;
                }
            },
            
            fastSinNorm(angle) {
                const idx = ((angle % this.PI2 + this.PI2) * this.RAD_TO_IDX) & 1023;
                return this.sinLUT[idx];
            }
        };
        OPT.init();

        // --- COMMON UTILS ---
        class Utils {
            static lerp(a, b, t) { return a + (b - a) * t; } 
            static lerpAngle(a, b, t) {
                let diff = b - a; while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2; return a + diff * t;
            }
            static clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
            static distSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx*dx + dy*dy; }
            static getPseudoRandom(x, y) { return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453; }
        }

        class ObjectPool {
            constructor(createFn, initialSize = 100) { this.createFn = createFn; this.pool = []; for (let i = 0; i < initialSize; i++) this.pool.push(this.createFn()); }
            get() { return this.pool.length > 0 ? this.pool.pop() : this.createFn(); }
            release(obj) { this.pool.push(obj); }
        }

        class SpatialGrid {
            constructor(cellSize) { this.cellSize = cellSize; this.invCellSize = 1 / cellSize; this.cells = new Map(); }
            _getKey(x, y) { return (Math.floor(x * this.invCellSize)) + "," + (Math.floor(y * this.invCellSize)); }
            insert(item) { const key = this._getKey(item.x, item.y); if (!this.cells.has(key)) this.cells.set(key, []); this.cells.get(key).push(item); item._spatialKey = key; }
            remove(item) { const key = item._spatialKey; if (!key || !this.cells.has(key)) return; const list = this.cells.get(key); const idx = list.indexOf(item); if (idx !== -1) { const last = list[list.length - 1]; list[idx] = last; list.pop(); if (list.length === 0) this.cells.delete(key); } item._spatialKey = null; }
            updateItem(item) { const newKey = this._getKey(item.x, item.y); if (newKey !== item._spatialKey) { this.remove(item); this.insert(item); } }
            query(rect, outArray) {
                outArray.length = 0; 
                const invCS = this.invCellSize;
                const startX = Math.floor(rect.x * invCS); const endX = Math.floor((rect.x + rect.w) * invCS); 
                const startY = Math.floor(rect.y * invCS); const endY = Math.floor((rect.y + rect.h) * invCS);
                for (let x = startX; x <= endX; x++) { for (let y = startY; y <= endY; y++) { const cell = this.cells.get(x + "," + y); if (cell) { for (let i = 0; i < cell.length; i++) outArray.push(cell[i]); } } }
            }
        }

        class SnakePath {
            constructor(initialCapacity = 1000) { this.capacity = initialCapacity; this.data = new Float32Array(this.capacity * 2); this.head = 0; this.length = 0; }
            addHead(x, y) { this.head = (this.head - 2 + this.data.length) % this.data.length; this.data[this.head] = x; this.data[this.head + 1] = y; this.length++; if (this.length * 2 >= this.data.length) this.resize(); }
            removeTail() { if (this.length > 0) this.length--; }
            getX(i) { return this.data[(this.head + i * 2) % this.data.length]; }
            getY(i) { return this.data[(this.head + i * 2 + 1) % this.data.length]; }
            resize() { const newCapacity = this.capacity * 2; const newData = new Float32Array(newCapacity * 2); for (let i = 0; i < this.length; i++) { const oldIdx = (this.head + i * 2) % this.data.length; newData[i * 2] = this.data[oldIdx]; newData[i * 2 + 1] = this.data[oldIdx + 1]; } this.data = newData; this.capacity = newCapacity; this.head = 0; }
        }

        // --- PREVIEW CLASS (EXACT COPY) ---
        class SnakePreview {
            constructor(canvas, initialSkin) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.skin = initialSkin; this.baseRadius = Config.Game.baseSnakeRadius; this.baseWaveAmp = 10; this.baseXOffset = 20; this.baseGap = Config.Game.pathGap; this.isBoosting = false; this.time = 0; this.running = true; this.blinkTimer = Math.random() * 200 + 100; this.blinkState = 0; this.eyeOpenness = 1.0; this.scale = 1; this.width = canvas.width || 300; this.height = canvas.height || 150; window.addEventListener('resize', () => this.handleResize()); this.handleResize(); this.animate(); }
            stop() { this.running = false; }
            start() { if (!this.running) { this.running = true; this.animate(); } }
            setSkin(skin) { this.skin = skin; this.updateSprites(); }
            setBoost(boosting) { this.isBoosting = boosting; }
            handleResize() { if(this.canvas.offsetParent === null) return; const rect = this.canvas.getBoundingClientRect(); this.width = rect.width; this.height = rect.height; this.canvas.width = this.width; this.canvas.height = this.height; const minDim = Math.min(this.width, this.height); let scale = (minDim / 200) * 2.0; this.scale = Utils.clamp(scale, 0.5, 4.0); this.radius = this.baseRadius * this.scale; this.waveAmp = this.baseWaveAmp * this.scale; this.xOffset = this.baseXOffset * this.scale; this.gap = this.baseGap * this.scale; const currentBaseSpeed = this.isBoosting ? Config.Game.boostSpeed : Config.Game.baseSpeed; this.speed = currentBaseSpeed * this.scale; this.updateSprites(); }
            updateSprites() { if (!this.radius) return; const r = this.radius; const sH = Math.ceil(r * 2.4); const cH = document.createElement('canvas'); cH.width = sH; cH.height = sH; const ctxH = cH.getContext('2d'); const cxH = sH/2; const gradH = ctxH.createRadialGradient(cxH-r*0.3, cxH-r*0.3, 0, cxH, cxH, r); gradH.addColorStop(0, this.skin.highlight); gradH.addColorStop(0.4, this.skin.primary); gradH.addColorStop(1, this.skin.secondary); ctxH.fillStyle = gradH; ctxH.beginPath(); ctxH.arc(cxH, cxH, r, 0, Math.PI*2); ctxH.fill(); this.headSprite = cH; const sB = Math.ceil(r * 2.2); const cB = document.createElement('canvas'); cB.width = sB; cB.height = sB; const ctxB = cB.getContext('2d'); const cxB = sB/2; const gradB = ctxB.createRadialGradient(cxB-r*0.3, cxB-r*0.3, 0, cxB, cxB, r); gradB.addColorStop(0, this.skin.highlight); gradB.addColorStop(0.3, this.skin.primary); gradB.addColorStop(1, this.skin.secondary); ctxB.fillStyle = gradB; ctxB.beginPath(); ctxB.arc(cxB, cxB, r, 0, Math.PI*2); ctxB.fill(); ctxB.fillStyle = 'rgba(255,255,255,0.15)'; ctxB.beginPath(); ctxB.ellipse(cxB-r*0.2, cxB-r*0.3, r*0.4, r*0.25, Math.PI/4, 0, Math.PI*2); ctxB.fill(); this.bodySprite = cB; }
            animate() { if(!this.running) return; this.update(); this.draw(); requestAnimationFrame(() => this.animate()); }
            update() { const targetSpeed = (this.isBoosting ? Config.Game.boostSpeed : Config.Game.baseSpeed) * this.scale; this.speed = targetSpeed; this.time += this.speed * 0.6; this.blinkTimer -= 1; const blinkSpeed = 8; if (this.blinkState === 0) { this.eyeOpenness = 1.0; if (this.blinkTimer <= 0) { this.blinkState = 1; this.blinkTimer = blinkSpeed; } } else if (this.blinkState === 1) { if (this.blinkTimer <= 0) { this.blinkState = 2; this.blinkTimer = blinkSpeed; this.eyeOpenness = 0.0; } else this.eyeOpenness = this.blinkTimer / blinkSpeed; } else if (this.blinkState === 2) { if (this.blinkTimer <= 0) { this.blinkState = 0; this.blinkTimer = Math.random() * 200 + 150; this.eyeOpenness = 1.0; } else this.eyeOpenness = 1.0 - (this.blinkTimer / blinkSpeed); } }
            draw() { if (!this.bodySprite || !this.headSprite) return; const ctx = this.ctx; ctx.clearRect(0, 0, this.width, this.height); const centerX = this.width / 2; const centerY = this.height / 2; const length = Config.Game.initialSnakeLength; const gap = this.gap; 
                // Draw shadows first
                ctx.save();
                for (let i = length; i >= 4; i -= 4) { const dist = i * gap; const x = centerX + this.xOffset - dist; const waveFreq = 0.05 / this.scale; const y = centerY + Math.sin((this.time - dist) * waveFreq) * this.waveAmp; if (x < -this.bodySprite.width) continue; ctx.beginPath(); ctx.arc(x + 3*this.scale, y + 4*this.scale, this.radius * 1.1, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fill(); }
                const headXShadow = centerX + this.xOffset; const waveFreqShadow = 0.05 / this.scale; const yShadow = centerY + Math.sin(this.time * waveFreqShadow) * this.waveAmp;
                ctx.beginPath(); ctx.arc(headXShadow + 3*this.scale, yShadow + 4*this.scale, this.radius * 1.15, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fill();
                ctx.restore();
                // Draw body
                for (let i = length; i >= 4; i -= 4) { const dist = i * gap; const x = centerX + this.xOffset - dist; const waveFreq = 0.05 / this.scale; const y = centerY + Math.sin((this.time - dist) * waveFreq) * this.waveAmp; if (x < -this.bodySprite.width) continue; ctx.drawImage(this.bodySprite, x - this.bodySprite.width/2, y - this.bodySprite.height/2); } const headX = centerX + this.xOffset; const waveFreq = 0.05 / this.scale; const y = centerY + Math.sin(this.time * waveFreq) * this.waveAmp; const slope = this.waveAmp * waveFreq * Math.cos(this.time * waveFreq); ctx.save(); ctx.translate(headX, y); ctx.rotate(Math.atan(slope)); ctx.drawImage(this.headSprite, -this.headSprite.width/2, -this.headSprite.height/2); const eyeX = (this.radius * 0.4); const eyeY = (this.radius * 0.55); const eyeRadius = (this.radius * 0.45); const drawEye = (side) => { const yOffset = side === 'left' ? -eyeY : eyeY; ctx.save(); ctx.translate(eyeX, yOffset); const blinkScale = this.eyeOpenness; if (blinkScale < 0.1) { ctx.beginPath(); ctx.moveTo(-eyeRadius, 0); ctx.lineTo(eyeRadius, 0); ctx.lineWidth = 2 * this.scale; ctx.strokeStyle = "#222"; ctx.stroke(); ctx.restore(); return; } ctx.scale(1, blinkScale); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, eyeRadius, 0, Math.PI*2); ctx.fill(); const pupilSize = eyeRadius * 0.55; const pDx = eyeRadius * 0.3; ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(pDx, 0, pupilSize, 0, Math.PI*2); ctx.fill(); if (this.eyeOpenness > 0.4) { ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.beginPath(); ctx.arc(pDx - pupilSize*0.3, -pupilSize*0.3, pupilSize*0.25, 0, Math.PI*2); ctx.fill(); } ctx.restore(); }; drawEye('left'); drawEye('right'); ctx.restore(); }
        }

        // --- INPUT MANAGER (EXACT COPY) ---
        class InputManager {
            constructor(canvas) { this.canvas = canvas; this.state = { mode: 'desktop', mouseX: window.innerWidth/2, mouseY: window.innerHeight/2, mouseDown: false, qKey: false }; this.qKeyLocked = false; this.joystick = { active: false, origin: {x:0,y:0}, current: {x:0,y:0}, radius: 50, id: null }; this.ui = { base: document.getElementById('joystick-base'), stick: document.getElementById('joystick-stick'), mobileHint: document.getElementById('mobile-hint'), mobileCashOutBtn: document.getElementById('mobile-cashout-btn') }; this.boostPointers = new Set(); this._initBindings(); }
            _initBindings() { this._boundDesktopMove = (e) => { this.state.mouseX = e.clientX; this.state.mouseY = e.clientY; }; this._boundDesktopDown = () => this.state.mouseDown = true; this._boundDesktopUp = () => this.state.mouseDown = false; this._boundKeyDown = (e) => { if (e.code === 'KeyQ' && !this.qKeyLocked) this.state.qKey = true; }; this._boundKeyUp = (e) => { if (e.code === 'KeyQ') { this.state.qKey = false; this.qKeyLocked = false; }}; this._boundPointerDown = this._handlePointerDown.bind(this); this._boundPointerMove = this._handlePointerMove.bind(this); this._boundPointerUp = this._handlePointerUp.bind(this); }
            setMode(mode) { this.cleanup(); this.state.mode = mode; if (mode === 'desktop') this._initDesktop(); else this._initMobile(); }
            cleanup() { window.removeEventListener('mousemove', this._boundDesktopMove); window.removeEventListener('mousedown', this._boundDesktopDown); window.removeEventListener('mouseup', this._boundDesktopUp); window.removeEventListener('keydown', this._boundKeyDown); window.removeEventListener('keyup', this._boundKeyUp); window.removeEventListener('pointerdown', this._boundPointerDown); window.removeEventListener('pointermove', this._boundPointerMove); window.removeEventListener('pointerup', this._boundPointerUp); window.removeEventListener('pointercancel', this._boundPointerUp); }
            _initDesktop() { window.addEventListener('mousemove', this._boundDesktopMove); window.addEventListener('mousedown', this._boundDesktopDown); window.addEventListener('mouseup', this._boundDesktopUp); window.addEventListener('keydown', this._boundKeyDown); window.addEventListener('keyup', this._boundKeyUp); }
            lockQ() { this.state.qKey = false; this.qKeyLocked = true; }
            _initMobile() { this.ui.mobileHint.style.display = 'block'; this.ui.mobileCashOutBtn.style.display = 'flex'; window.addEventListener('pointerdown', this._boundPointerDown, { passive: false }); window.addEventListener('pointermove', this._boundPointerMove, { passive: false }); window.addEventListener('pointerup', this._boundPointerUp, { passive: false }); window.addEventListener('pointercancel', this._boundPointerUp, { passive: false }); window.addEventListener('contextmenu', e => e.preventDefault()); if (!this.ui.mobileCashOutBtn.hasAttribute('data-init')) { const handleCashOutStart = (e) => { e.preventDefault(); e.stopPropagation(); if (!this.qKeyLocked) this.state.qKey = true; }; const handleCashOutEnd = (e) => { e.preventDefault(); e.stopPropagation(); this.state.qKey = false; this.qKeyLocked = false; }; this.ui.mobileCashOutBtn.addEventListener('pointerdown', handleCashOutStart); this.ui.mobileCashOutBtn.addEventListener('pointerup', handleCashOutEnd); this.ui.mobileCashOutBtn.addEventListener('pointercancel', handleCashOutEnd); this.ui.mobileCashOutBtn.addEventListener('touchstart', handleCashOutStart, {passive: false}); this.ui.mobileCashOutBtn.addEventListener('touchend', handleCashOutEnd, {passive: false}); this.ui.mobileCashOutBtn.setAttribute('data-init', 'true'); } }
            _handlePointerDown(e) { if (e.target.closest('#main-menu-overlay') || e.target.closest('#mobile-cashout-btn')) return; e.preventDefault(); const { clientX: x, clientY: y, pointerId } = e; 
                // Adapt coordinates for forced rotation
                const p = this._mapInputCoordinates(x, y);
                try { this.canvas.setPointerCapture(pointerId); } catch (err) {} 
                // Use mapped coordinates for joystick logic
                if (p.x < window.innerWidth / 2) { 
                    if (this.joystick.active) { this.joystick.active = false; this.ui.base.style.display = 'none'; } 
                    this.joystick.active = true; this.joystick.id = pointerId; 
                    this.joystick.origin = { x: p.x, y: p.y }; this.joystick.current = { x: p.x, y: p.y }; 
                    this.ui.base.style.display = 'block'; 
                    // Note: UI positioning might need CSS adjustment, but simple mapped values work for logic
                    this.ui.base.style.left = x + 'px'; this.ui.base.style.top = y + 'px'; // Visual pos matches touch
                    this.ui.stick.style.transform = `translate(-50%, -50%)`; 
                    if(this.ui.mobileHint) this.ui.mobileHint.style.opacity = '0'; 
                } else { this.boostPointers.add(pointerId); this.state.mouseDown = true; if(this.ui.mobileHint) this.ui.mobileHint.style.opacity = '0'; } }
            
            _handlePointerMove(e) { if (!this.joystick.active && this.boostPointers.size === 0) return; e.preventDefault(); if (this.joystick.active && e.pointerId === this.joystick.id) { 
                const p = this._mapInputCoordinates(e.clientX, e.clientY);
                const dx = p.x - this.joystick.origin.x; const dy = p.y - this.joystick.origin.y; 
                const angle = Math.atan2(dy, dx); const dist = Math.min(Math.hypot(dx, dy), this.joystick.radius); 
                const stickX = Math.cos(angle) * dist; const stickY = Math.sin(angle) * dist; 
                this.ui.stick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`; 
                const projectionDist = 300; 
                // Project mouse pos based on joystick angle
                this.state.mouseX = (window.innerWidth / 2) + Math.cos(angle) * projectionDist; 
                this.state.mouseY = (window.innerHeight / 2) + Math.sin(angle) * projectionDist; } }
            
            _handlePointerUp(e) { if (e.target.closest('#main-menu-overlay')) return; e.preventDefault(); if (this.joystick.active && e.pointerId === this.joystick.id) { this.joystick.active = false; this.joystick.id = null; this.ui.base.style.display = 'none'; } if (this.boostPointers.has(e.pointerId)) { this.boostPointers.delete(e.pointerId); if (this.boostPointers.size === 0) this.state.mouseDown = false; } try { this.canvas.releasePointerCapture(e.pointerId); } catch(err){} }
            
            // Helper to swap coordinates if rotated via CSS
            _mapInputCoordinates(clientX, clientY) {
                // Check if we are in portrait mode on mobile (where CSS rotation is applied)
                if (window.innerWidth < window.innerHeight && window.innerWidth <= 900) {
                    // Map visual touch coordinates to logical game coordinates (rotated -90deg)
                    // Visual X becomes Game Y, Visual Y becomes inverted Game X
                    // Assuming rotation origin bottom-left and clockwise 90deg transform
                    return { x: clientY, y: window.innerWidth - clientX };
                }
                return { x: clientX, y: clientY };
            }

            getInputState() { return this.state; }
        }

        // --- LEADERBOARD MANAGER (EXACT COPY) ---
        class LeaderboardManager {
            constructor() { this.listElement = document.getElementById('lb-list'); }
            update(timestamp, playerScore, playerName) { const topList = [{ name: playerName || "YOU", score: Math.floor(playerScore), isMe: true }]; this.listElement.innerHTML = ''; topList.forEach((p, index) => { const li = document.createElement('li'); li.className = 'lb-item' + (p.isMe ? ' is-me' : ''); li.innerHTML = `<span class="lb-rank">#${index + 1}</span><span class="lb-name">${p.name}</span><span class="lb-score">${p.score}</span>`; this.listElement.appendChild(li); }); }
        }

        /**
         * =================================================================================
         * SERVER SIMULATION ENGINE (Pure Logic)
         * =================================================================================
         */
        
        class SnakeLogic {
            constructor(id, nickname, skinId) {
                this.id = id;
                this.nickname = nickname;
                this.skinId = skinId;
                this.x = 0; 
                this.y = 0;
                this.angle = -Math.PI / 2;
                this.targetAngle = this.angle;
                
                this.prevX = 0; 
                this.prevY = 0;
                this.prevAngle = this.angle;

                this.score = 0;
                this.radius = Config.Game.baseSnakeRadius;
                this.targetLength = Config.Game.initialSnakeLength;
                
                this.boosting = false;
                this.isCashingOut = false;
                this.cashOutTimer = 0;
                this.isDead = false;

                this.path = new SnakePath(2000);
                this._initPath();
            }

            _initPath() {
                const initLen = this.targetLength;
                const gap = Config.Game.pathGap;
                for(let i=0; i < initLen; i++) { 
                    this.path.addHead(this.x, this.y + (i * gap)); 
                }
            }

            tick(input, worldRadius) {
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevAngle = this.angle;

                if(this.isDead) return;

                if (input.qKey) {
                    this.isCashingOut = true;
                    this.boosting = false;
                    this.cashOutTimer += Config.Game.tickTime;
                    if (this.cashOutTimer >= 3000) { 
                        this.isDead = true; 
                        return;
                    }
                } else {
                    this.isCashingOut = false;
                    this.cashOutTimer = 0;
                    this.boosting = input.mouseDown;
                }

                if (this.boosting) {
                    this._updateRadius();
                }

                if (!this.isCashingOut) {
                    const dx = input.mouseX - (window.innerWidth / 2);
                    const dy = input.mouseY - (window.innerHeight / 2);
                    this.targetAngle = Math.atan2(dy, dx);

                    const scale = this.radius / Config.Game.baseSnakeRadius;
                    const turnRate = Config.Game.turnSpeed * Math.pow(1 / scale, 1.2);

                    this.angle = Utils.lerpAngle(this.angle, this.targetAngle, turnRate);
                }

                const baseSpeed = this.boosting ? Config.Game.boostSpeed : Config.Game.baseSpeed;
                const speed = baseSpeed;

                const nextX = this.x + Math.cos(this.angle) * speed;
                const nextY = this.y + Math.sin(this.angle) * speed;

                const limit = worldRadius - this.radius;
                if (nextX * nextX + nextY * nextY > limit * limit) {
                    this.isDead = true;
                    return;
                }

                this.x = nextX;
                this.y = nextY;

                const scale = this.radius / Config.Game.baseSnakeRadius;
                this._updatePath(scale);
            }

            _updatePath(scale) {
                if (this.path.length === 0) this.path.addHead(this.x, this.y);
                const headX = this.path.getX(0); 
                const headY = this.path.getY(0);
                const distDx = this.x - headX; 
                const distDy = this.y - headY;
                const dist = Math.hypot(distDx, distDy);
                
                const gap = Config.Game.pathGap * scale;

                if (dist >= gap) {
                    const count = Math.floor(dist / gap); 
                    const stepX = (distDx / dist) * gap; 
                    const stepY = (distDy / dist) * gap; 
                    for (let i = 1; i <= count; i++) { 
                        this.path.addHead(headX + stepX * i, headY + stepY * i); 
                    } 
                    while (this.path.length > this.targetLength) { 
                        this.path.removeTail(); 
                    } 
                }
            }

            addScore(val) {
                this.score += val;
                this._updateRadius();
            }

            _updateRadius() {
                this.targetLength = Config.Game.initialSnakeLength + Math.floor(this.score / 5);
                const widthGrowthFactor = 0.28;
                const targetR = Config.Game.baseSnakeRadius + Math.min(20, Math.sqrt(this.score) * widthGrowthFactor);
                this.radius = this.radius * 0.9 + targetR * 0.1;
            }
        }

        class FoodLogic {
            constructor(worldRadius) {
                this.worldRadius = worldRadius;
                this.pool = new ObjectPool(() => ({ x:0, y:0, value:1, spriteKey: 3, size:4, vx:0, vy:0, id:0 }), 500);
                this.grid = new SpatialGrid(250);
                this.movingFoods = [];
                this.lastSpawnTime = 0;
                this.spawnBatch(Config.Food.count);
            }

            spawnBatch(count) { for (let i = 0; i < count; i++) this._spawnOne(); }

            _spawnOne() {
                const f = this.pool.get();
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.sqrt(Math.random()) * (this.worldRadius - 50);
                const rand = Math.random();
                
                // 1 очко — 60%, 2 очка — 25%, 3 очка — 10%, 5 очков — 5% (движется)
                let value = 1, spriteKey = 3, size = 4;
                if (rand < 0.05) { value = 5; spriteKey = 0; size = 6; }
                else if (rand < 0.15) { value = 3; spriteKey = 1; size = 5; }
                else if (rand < 0.40) { value = 2; spriteKey = 2; size = 4.5; }

                f.x = Math.cos(angle) * dist;
                f.y = Math.sin(angle) * dist;
                f.value = value;
                f.spriteKey = spriteKey;
                f.size = size;
                f.id = Math.random();

                if (value === 5) {
                    f.vx = (Math.random()-0.5)*1.5;
                    f.vy = (Math.random()-0.5)*1.5;
                    this.movingFoods.push(f);
                } else {
                    f.vx = 0; f.vy = 0;
                }
                this.grid.insert(f);
            }

            tick() {
                this.lastSpawnTime += Config.Game.tickTime;
                if (this.lastSpawnTime > Config.Food.spawnInterval) {
                    this._spawnOne();
                    this.lastSpawnTime = 0;
                }

                const limitSq = (this.worldRadius - 50) ** 2;
                for (let i = this.movingFoods.length - 1; i >= 0; i--) {
                    const f = this.movingFoods[i];
                    f.x += f.vx; f.y += f.vy;
                    if (Utils.distSq(f.x, f.y, 0, 0) > limitSq) {
                        const a = Math.atan2(f.y, f.x);
                        f.vx = -Math.cos(a)*Math.abs(f.vx);
                        f.vy = -Math.sin(a)*Math.abs(f.vy);
                    }
                    if (Math.random() < 0.02) {
                        f.vx = (Math.random()-0.5)*1.5;
                        f.vy = (Math.random()-0.5)*1.5;
                    }
                    this.grid.updateItem(f);
                }
            }

            checkCollisions(snake) {
                if(!snake) return;
                const buffer = OPT._foodQueryBuffer;
                const toRemove = OPT._toRemoveBuffer;
                toRemove.length = 0;
                
                const checkDist = snake.radius * 4;
                const queryRect = { x: snake.x - checkDist, y: snake.y - checkDist, w: checkDist*2, h: checkDist*2 };
                
                this.grid.query(queryRect, buffer);
                
                const eatDistSq = (snake.radius * 1.5) ** 2;
                const magnetDistSq = (snake.radius * 4) ** 2;

                for (const f of buffer) {
                    const dx = snake.x - f.x;
                    const dy = snake.y - f.y;
                    const dSq = dx*dx + dy*dy;

                    if (dSq < eatDistSq) {
                        snake.addScore(f.value);
                        toRemove.push(f);
                    } else if (dSq < magnetDistSq) {
                        const dist = Math.sqrt(dSq);
                        f.x += (dx/dist)*2.5;
                        f.y += (dy/dist)*2.5;
                        this.grid.updateItem(f);
                    }
                }

                for (const f of toRemove) {
                    this.grid.remove(f);
                    if (f.value === 5) {
                        const idx = this.movingFoods.indexOf(f);
                        if(idx !== -1) {
                            this.movingFoods[idx] = this.movingFoods[this.movingFoods.length-1];
                            this.movingFoods.pop();
                        }
                    }
                    this.pool.release(f);
                }
            }
        }

        class ServerEngine {
            constructor() {
                this.snakes = new Map();
                this.foodManager = new FoodLogic(Config.Game.worldRadius);
                this.worldRadius = Config.Game.worldRadius;
            }

            addPlayer(id, name, skinId) {
                const s = new SnakeLogic(id, name, skinId);
                this.snakes.set(id, s);
                return s;
            }

            removePlayer(id) {
                this.snakes.delete(id);
            }

            tick(inputs, timestamp) {
                const pulse = Math.sin(timestamp * 0.001);
                this.worldRadius = Config.Game.worldRadius + (pulse * 30);
                this.foodManager.worldRadius = this.worldRadius;

                this.foodManager.tick();

                this.snakes.forEach(snake => {
                    const input = inputs[snake.id];
                    if (input) {
                        snake.tick(input, this.worldRadius);
                        this.foodManager.checkCollisions(snake);
                    }
                });

                this._checkPlayerCollisions();

                const deadIds = [];
                this.snakes.forEach(s => {
                    if(s.isDead) deadIds.push(s.id);
                });
                
                return deadIds;
            }

            _checkPlayerCollisions() {
                const snakesArr = OPT._snakesCache;
                snakesArr.length = 0;
                this.snakes.forEach(s => snakesArr.push(s));
                
                const stride = 3;

                for (let i = 0; i < snakesArr.length; i++) {
                    const sA = snakesArr[i];
                    if (sA.isDead || sA.isCashingOut) continue;

                    const raX = sA.radius * 0.9;
                    const raY = sA.radius * 0.5;
                    const cosA = Math.cos(-sA.angle);
                    const sinA = Math.sin(-sA.angle);

                    for (let j = 0; j < snakesArr.length; j++) {
                        const sB = snakesArr[j];
                        if (sB.isDead) continue;
                        
                        if (sA === sB) continue;

                        for (let k = 0; k < sB.path.length; k += stride) {
                            this._testHitbox(sA, sB.path.getX(k), sB.path.getY(k), sB.radius, raX, raY, cosA, sinA);
                            if(sA.isDead) break;
                        }
                        
                        if(sA.isDead) break;
                    }
                }
            }

            _testHitbox(snakeHead, bx, by, bRadius, raX, raY, cosA, sinA) {
                const dx = bx - snakeHead.x;
                const dy = by - snakeHead.y;
                
                const lx = dx * cosA - dy * sinA;
                const ly = dx * sinA + dy * cosA;

                const factorX = raX + bRadius * 0.8;
                const factorY = raY + bRadius * 0.8;
                
                const distSq = (lx * lx) / (factorX * factorX) + (ly * ly) / (factorY * factorY);
                
                if (distSq <= 1) {
                    snakeHead.isDead = true;
                }
            }
        }

        /**
         * =================================================================================
         * CLIENT RENDERER (View) with CLIENT PREDICTION
         * =================================================================================
         */

        class SnakeRenderer {
            constructor(skinId, assets) {
                this.assets = assets;
                const skin = Config.Skins.find(s => s.id === skinId) || Config.Skins[0];
                this.color = skin.primary;
                this.secondary = skin.secondary;
                this.highlight = skin.highlight;
                
                this.blinkTimer = Math.random() * 200 + 100;
                this.blinkState = 0;
                this.eyeOpenness = 1.0;
                this.lookAngle = 0;

                this.headSprite = this._createHead(Config.Game.baseSnakeRadius);
                this.bodySprite = this._createBody(Config.Game.baseSnakeRadius);
            }

            _createBody(r) {
                const s = Math.ceil(r * 2.2); const c = document.createElement('canvas'); c.width = s; c.height = s; const ctx = c.getContext('2d'); const cx = s/2; 
                const g = ctx.createRadialGradient(cx-r*0.3, cx-r*0.3, 0, cx, cx, r); g.addColorStop(0, this.highlight); g.addColorStop(0.3, this.color); g.addColorStop(1, this.secondary);
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cx, r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.ellipse(cx-r*0.2, cx-r*0.3, r*0.4, r*0.25, Math.PI/4, 0, Math.PI*2); ctx.fill(); return c;
            }

            _createHead(r) {
                const s = Math.ceil(r * 2.4); const c = document.createElement('canvas'); c.width = s; c.height = s; const ctx = c.getContext('2d'); const cx = s/2;
                const g = ctx.createRadialGradient(cx-r*0.3, cx-r*0.3, 0, cx, cx, r); g.addColorStop(0, this.highlight); g.addColorStop(0.4, this.color); g.addColorStop(1, this.secondary);
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cx, r, 0, Math.PI*2); ctx.fill(); return c;
            }

            updateVisuals(targetAngle, currentAngle) {
                let da = targetAngle - currentAngle;
                while (da > Math.PI) da -= Math.PI * 2; while (da < -Math.PI) da += Math.PI * 2;
                da = Utils.clamp(da, -Math.PI/2.2, Math.PI/2.2);
                this.lookAngle = Utils.lerpAngle(this.lookAngle, da, 0.1);

                this.blinkTimer--;
                if (this.blinkState === 0) { this.eyeOpenness = 1.0; if (this.blinkTimer <= 0) { this.blinkState = 1; this.blinkTimer = 8; } }
                else if (this.blinkState === 1) { if (this.blinkTimer <= 0) { this.blinkState = 2; this.blinkTimer = 8; this.eyeOpenness = 0; } else this.eyeOpenness = this.blinkTimer/8; }
                else if (this.blinkState === 2) { if (this.blinkTimer <= 0) { this.blinkState = 0; this.blinkTimer = Math.random()*200+150; this.eyeOpenness = 1; } else this.eyeOpenness = 1 - (this.blinkTimer/8); }
            }

            draw(ctx, snake, alpha, viewBounds, isHighQuality) {
                // Interpolate head position and angle
                const ix = Utils.lerp(snake.prevX, snake.x, alpha);
                const iy = Utils.lerp(snake.prevY, snake.y, alpha);
                const iAngle = Utils.lerpAngle(snake.prevAngle, snake.angle, alpha);
                
                // Offset to apply to entire body for smooth movement
                const offsetX = ix - snake.x;
                const offsetY = iy - snake.y;

                this.updateVisuals(snake.targetAngle, snake.angle);

                if (snake.path.length < 2) return;

                const scale = snake.radius / Config.Game.baseSnakeRadius;
                const stride = Math.max(4, Math.floor(2 * scale + 2));
                
                const buffer = (snake.radius * 4.5 * scale) / 2 + 50; 
                const {x:vx, y:vy, w:vw, h:vh} = viewBounds;

                // Apply offset to entire snake for smooth interpolation
                ctx.save();
                ctx.translate(offsetX, offsetY);

                // Draw shadows
                if (this.assets.shadowSprite) {
                    const sSize = this.assets.shadowSprite.width * scale;
                    for (let i = snake.path.length - 1; i >= 0; i -= stride) {
                        const px = snake.path.getX(i); const py = snake.path.getY(i);
                        if (px + offsetX < vx-buffer || px + offsetX > vx+vw+buffer || py + offsetY < vy-buffer || py + offsetY > vy+vh+buffer) continue;
                        ctx.drawImage(this.assets.shadowSprite, px - sSize/2 + 2*scale, py - sSize/2 + 2*scale, sSize, sSize);
                    }
                }

                // Boost trail
                if (snake.boosting) {
                    ctx.save();
                    ctx.lineJoin = "round"; ctx.lineCap = "round";
                    ctx.strokeStyle = "#FFFFFF";
                    ctx.lineWidth = snake.radius * 2.35;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = "rgba(255, 255, 255, 0.15)";
                    ctx.beginPath();
                    ctx.moveTo(snake.x, snake.y);
                    for (let i = stride; i < snake.path.length; i += stride) {
                        ctx.lineTo(snake.path.getX(i), snake.path.getY(i));
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // Draw body segments
                const bSize = this.bodySprite.width * scale;
                for (let i = snake.path.length - 1; i >= 0; i -= stride) {
                    const px = snake.path.getX(i); const py = snake.path.getY(i);
                    if (px + offsetX < vx-buffer || px + offsetX > vx+vw+buffer || py + offsetY < vy-buffer || py + offsetY > vy+vh+buffer) continue;
                    ctx.drawImage(this.bodySprite, px - bSize/2, py - bSize/2, bSize, bSize);
                }

                // Draw head
                ctx.save(); 
                ctx.translate(snake.x, snake.y); 
                ctx.rotate(iAngle);
                const hSize = this.headSprite.width * scale;
                ctx.drawImage(this.headSprite, -hSize/2, -hSize/2, hSize, hSize);

                const eX = (Config.Game.baseSnakeRadius * 0.4) * scale;
                const eY = (Config.Game.baseSnakeRadius * 0.55) * scale;
                const eR = (Config.Game.baseSnakeRadius * 0.45) * scale;
                
                const drawEye = (mult) => {
                    ctx.save(); ctx.translate(eX, eY * mult);
                    if (this.eyeOpenness < 0.1) {
                        ctx.beginPath(); ctx.moveTo(-eR, 0); ctx.lineTo(eR, 0); ctx.lineWidth = 2 * scale; ctx.strokeStyle="#222"; ctx.stroke();
                    } else {
                        ctx.scale(1, this.eyeOpenness); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0,eR,0,Math.PI*2); ctx.fill();
                        const pSize = eR * 0.55;
                        const pDx = Math.cos(this.lookAngle) * (eR * 0.3);
                        const pDy = Math.sin(this.lookAngle) * (eR * 0.3);
                        ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(pDx, pDy, pSize, 0, Math.PI*2); ctx.fill();
                        if (isHighQuality && this.eyeOpenness > 0.4) {
                            ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.beginPath(); ctx.arc(pDx - pSize*0.3, pDy - pSize*0.3, pSize*0.25, 0, Math.PI*2); ctx.fill();
                        }
                    }
                    ctx.restore();
                };
                drawEye(-1); drawEye(1);
                ctx.restore();

                // Nickname
                ctx.save();
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.font = `bold ${Math.max(12, 12 * scale)}px "Exo 2"`;
                ctx.textAlign = "center";
                ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 4;
                ctx.fillText(snake.nickname, snake.x, snake.y - (snake.radius * 2.5));
                ctx.restore();

                // Cashout ring
                if (snake.isCashingOut && snake.cashOutTimer > 0) {
                    const p = Math.min(1, snake.cashOutTimer / 3000); 
                    const r = snake.radius * 1.8;
                    const lineWidth = 4 * scale; 

                    ctx.save(); ctx.translate(snake.x, snake.y); 
                    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); 
                    ctx.strokeStyle="rgba(255,255,255,0.25)"; 
                    ctx.lineWidth = lineWidth; 
                    ctx.stroke();
                    
                    if(p>0) { 
                        ctx.beginPath(); 
                        ctx.arc(0,0,r, -Math.PI/2, -Math.PI/2 + (Math.PI*2*p)); 
                        ctx.strokeStyle="#ffd700"; 
                        ctx.lineWidth = lineWidth; 
                        ctx.lineCap="round"; 
                        ctx.stroke(); 
                    }
                    ctx.restore();
                }

                ctx.restore();
            }
        }

        class ClientEngine {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.assets = { hexFrames: [], foodSprites: [], shadowSprite: null, vignette: null, minimapBg: null };
                
                this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
                this.width = this.canvas.width; this.height = this.canvas.height;
                this.highQuality = true;

                this.server = new ServerEngine();
                this.input = new InputManager(this.canvas);
                this.leaderboard = new LeaderboardManager();
                this.playerId = null;
                this.snakeRenderer = null;
                this.isRunning = false;
                
                this.lastTime = 0;
                this.accumulator = 0;
                this.fpsLimit = 'auto';
                this.frameCount = 0;
                this.lastFpsTime = 0;

                this.camera = { x: 0, y: 0 };
                this.prevCamera = { x: 0, y: 0 };
                this.gameZoom = 1;
                this.renderZoom = 1;
                
                this._hexPhaseCache = new Map();

                this._initAssets();
                this._initMenu();
                
                window.addEventListener('resize', () => this.resize());
                this.resize();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.gameZoom = Utils.clamp(Math.sqrt((this.width*this.height)/Config.Game.targetVisibleArea), 0.4, 1.5);
                
                const minDim = Math.min(this.width, this.height);
                Config.Minimap.radius = Utils.clamp(minDim * 0.135, 65, 135);

                this._initMinimapBg();
                this._initVignette();
            }

            _initAssets() { this._initHex(); this._initShadow(); this._initFood(); this._initMinimapBg(); this._initVignette(); }
            
            _initHex() {
                // Fix: Clear existing frames to prevent duplication/memory leak
                this.assets.hexFrames = [];

                const r = Config.Background.hexSize; 
                const gap = Config.Background.hexGap; 
                const drawR = Math.max(0, r - gap/2);
                const size = Math.ceil(drawR * 2 + 2); 
                const cx = size/2; const cy = size/2;
                const levels = Config.Background.cacheLevels;

                const hexOffsets = [];
                for (let i = 0; i < 6; i++) { 
                    const angle = (Math.PI / 180) * (60 * i); 
                    hexOffsets.push({ x: drawR * Math.cos(angle), y: drawR * Math.sin(angle) }); 
                }

                for(let i=0; i<levels; i++) {
                    const c = document.createElement('canvas'); c.width = size; c.height = size; const ctx = c.getContext('2d');
                    const t = i / (levels - 1);
                    const l = Config.Background.lightnessBase + (Config.Background.lightnessPulse - Config.Background.lightnessBase) * t;
                    
                    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, drawR); 
                    g.addColorStop(0, `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, ${l}%)`); 
                    g.addColorStop(0.8, `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, ${Math.max(0, l-2)}%)`); 
                    g.addColorStop(1, `hsl(${Config.Background.hue}, ${Config.Background.saturation}%, 0%)`);
                    
                    ctx.fillStyle = g; 
                    ctx.beginPath();
                    for(let j=0; j<6; j++) { 
                        const px = cx + hexOffsets[j].x; 
                        const py = cy + hexOffsets[j].y; 
                        if(j===0) ctx.moveTo(px, py); else ctx.lineTo(px, py); 
                    }
                    ctx.closePath();
                    ctx.fill(); 
                    this.assets.hexFrames.push(c);
                }
            }

            _initShadow() {
                const r = Config.Game.baseSnakeRadius; const s = r*4.5; const c = document.createElement('canvas'); c.width=s; c.height=s; const ctx=c.getContext('2d');
                const g = ctx.createRadialGradient(s/2,s/2, r*0.2, s/2,s/2, r*2); g.addColorStop(0,'rgba(0,0,0,0.65)'); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,s,s); this.assets.shadowSprite = c;
            }
            _initFood() {
                const cols = ['#ffd700', '#ff55ff', '#55ffff', '#55ff55'];
                this.assets.foodSprites = cols.map((col, i) => {
                    const size = 7 - i; const glow = 10; const dim = (size+glow)*2;
                    const c = document.createElement('canvas'); c.width=dim; c.height=dim; const ctx=c.getContext('2d');
                    ctx.shadowColor=col; ctx.shadowBlur=glow; ctx.fillStyle=col;
                    ctx.beginPath(); ctx.arc(dim/2, dim/2, size, 0, Math.PI*2); ctx.fill(); return c;
                });
            }
            _initMinimapBg() {
                const m = Config.Minimap; const s = (m.radius + m.margin)*2; const c = document.createElement('canvas'); c.width=s; c.height=s; const ctx=c.getContext('2d');
                const g = ctx.createRadialGradient(s/2,s/2, m.radius*0.1, s/2,s/2, m.radius); g.addColorStop(0, m.bgCenter); g.addColorStop(1, m.bgEdge);
                ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s/2,s/2, m.radius, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle=m.borderColor; ctx.lineWidth=1; ctx.stroke(); this.assets.minimapBg = c;
            }
            _initVignette() {
                const c = document.createElement('canvas'); c.width=this.width; c.height=this.height; const ctx=c.getContext('2d');
                const r = Math.hypot(this.width/2, this.height/2);
                const g = ctx.createRadialGradient(this.width/2, this.height/2, r*0.5, this.width/2, this.height/2, r);
                g.addColorStop(0, 'transparent'); g.addColorStop(1, 'rgba(0,0,0,0.7)');
                ctx.fillStyle=g; ctx.fillRect(0,0,this.width, this.height); this.assets.vignette = c;
            }

            setLanguage(lang) {
                const t = Translations[lang];
                if (!t) return;
                
                const ids = {
                    'txt-top-winners': t.topWinners, 'txt-live': t.live, 'txt-daily': t.daily, 
                    'txt-week': t.week, 'txt-month': t.month, 'txt-global': t.global, 
                    'txt-free': t.free, 'btn-play': t.joinLobby, 'txt-commission': t.commission,
                    'txt-balance': t.balance, 'txt-deposit': t.deposit, 'txt-withdraw': t.withdraw, 
                    'txt-preferences': t.preferences, 'txt-graphics': t.graphics, 
                    'txt-performance': t.performance, 'txt-quality': t.quality, 'txt-input': t.input, 
                    'txt-touch': t.touch, 'txt-mouse': t.mouse, 'txt-language': t.language, 
                    'txt-controls': t.controls, 'txt-mouse-move': t.mouseMove, 
                    'txt-hold-boost': t.holdBoost, 'txt-touch-move': t.touchMove, 
                    'txt-hold-boost-mob': t.holdBoostMobile, 'txt-cash-out': t.cashOut, 
                    'txt-cash-out-mob': t.cashOut, 'txt-hud-lb': t.hudLb, 
                    'txt-fps-limit': t.fpsLimit, 'txt-vsync': t.vsync
                };

                for (const [id, text] of Object.entries(ids)) {
                    const el = document.getElementById(id);
                    if (el) el.textContent = text;
                }

                const nameInput = document.getElementById('nickname-input');
                if (nameInput) nameInput.placeholder = t.nickname;

                const vsyncToggle = document.getElementById('vsync-toggle');
                if (vsyncToggle) {
                    vsyncToggle.querySelector('button[data-val="auto"]').textContent = t.auto;
                    vsyncToggle.querySelector('button[data-val="custom"]').textContent = t.custom;
                }
                
                const fpsValEl = document.getElementById('fps-value'); 
                if(fpsValEl && this.fpsLimit === 'auto') fpsValEl.textContent = t.auto;

                // Update online labels
                document.querySelectorAll('.lbl-online').forEach(el => el.textContent = t.online);
            }

            _initMenu() {
                const menu = document.getElementById('main-menu-overlay');
                const btnPlay = document.getElementById('btn-play');
                const nameInput = document.getElementById('nickname-input');
                const isMobile = /Android|iPhone/i.test(navigator.userAgent);
                let settings = { skin: Config.Skins[0].id, mode: isMobile?'mobile':'desktop' };

                // Fix #3: Generate random guest name
                const randomSuffix = Math.floor(10000 + Math.random() * 90000);
                nameInput.value = `Guest_${randomSuffix}`;

                const cp = document.getElementById('color-picker'); cp.innerHTML='';
                Config.Skins.forEach(s => {
                    const d = document.createElement('div'); d.className = 'color-swatch' + (s.id===settings.skin?' active':'');
                    d.style.background = s.primary;
                    d.onclick = () => { settings.skin = s.id; document.querySelectorAll('.color-swatch').forEach(e=>e.classList.remove('active')); d.classList.add('active'); this._updatePreview(s); };
                    cp.appendChild(d);
                });

                const bindToggle = (id, fn) => {
                    const container = document.getElementById(id);
                    if (!container) return;
                    container.querySelectorAll('button').forEach(b => {
                        b.onclick = () => { 
                            b.parentElement.querySelectorAll('button').forEach(x=>x.classList.remove('active')); 
                            b.classList.add('active'); 
                            fn(b.dataset.val); 
                        };
                    });
                };

                bindToggle('graphics-toggle', v => { this.highQuality = v === 'high'; this._initHex(); });
                bindToggle('device-toggle', v => settings.mode = v);

                bindToggle('lang-toggle', v => this.setLanguage(v));
                
                const lobbyContainer = document.getElementById('lobby-selector');
                if (lobbyContainer) {
                    lobbyContainer.querySelectorAll('.lobby-btn').forEach(btn => {
                        btn.onclick = () => { 
                            lobbyContainer.querySelectorAll('.lobby-btn').forEach(b => b.classList.remove('active')); 
                            btn.classList.add('active'); 
                        };
                    });
                }

                const lbTabs = document.getElementById('lb-tabs');
                if (lbTabs) {
                    lbTabs.querySelectorAll('.lb-tab').forEach(btn => {
                        btn.onclick = () => { 
                            lbTabs.querySelectorAll('.lb-tab').forEach(b => b.classList.remove('active')); 
                            btn.classList.add('active'); 
                        };
                    });
                }

                const fpsWrapper = document.getElementById('fps-slider-wrapper');
                const fpsSlider = document.getElementById('fps-slider');
                const fpsValue = document.getElementById('fps-value');
                const fpsSteps = [30, 45, 60, 90, 120, 144, 165, 240, 360];

                bindToggle('vsync-toggle', val => {
                    if (val === 'auto') {
                        this.fpsLimit = 'auto';
                        fpsWrapper.classList.add('hidden');
                        fpsValue.textContent = Translations['en'].auto;
                    } else {
                        fpsWrapper.classList.remove('hidden');
                        this.fpsLimit = fpsSteps[parseInt(fpsSlider.value)];
                        fpsValue.textContent = this.fpsLimit;
                    }
                });

                fpsSlider.oninput = (e) => {
                    const val = fpsSteps[parseInt(e.target.value)];
                    this.fpsLimit = val;
                    fpsValue.textContent = val;
                };

                this.setLanguage('en');
                
                this.preview = new SnakePreview(document.getElementById('skin-preview'), Config.Skins[0]);

                btnPlay.onclick = () => {
                    const name = nameInput.value.trim() || "Guest";
                    menu.style.opacity = '0'; setTimeout(()=>menu.style.display='none', 500);
                    
                    // SHOW GAME UI
                    document.getElementById('ui-leaderboard').style.display = 'block';
                    document.getElementById('ui-stats').style.display = 'flex';

                    if(settings.mode === 'desktop') { document.getElementById('ui-desktop').style.display='block'; document.getElementById('ui-cashout').style.display='flex'; }
                    this.input.setMode(settings.mode);
                    this.start(name, settings.skin);
                };
            }
            _updatePreview(skin) { if(this.preview) this.preview.setSkin(skin); }

            start(name, skinId) {
                this.playerId = 'local_player';
                const snake = this.server.addPlayer(this.playerId, name, skinId);
                this.snakeRenderer = new SnakeRenderer(skinId, this.assets);
                
                this.isRunning = true;
                this.lastTime = performance.now();
                this.accumulator = 0;
                
                this.camera = { x: snake.x, y: snake.y };
                this.prevCamera = { ...this.camera };
                
                this._hexPhaseCache.clear();
                
                this.loop(this.lastTime);
            }

            loop(timestamp) {
                if(!this.isRunning) return;
                requestAnimationFrame(t => this.loop(t));

                const dt = timestamp - this.lastTime;
                
                if (this.fpsLimit !== 'auto') {
                    const interval = 1000 / this.fpsLimit;
                    if (dt < interval) return;
                    this.lastTime = timestamp - (dt % interval);
                } else {
                    this.lastTime = timestamp;
                }
                
                this.accumulator += Math.min(dt, 250);

                while (this.accumulator >= Config.Game.tickTime) {
                    this._serverTick(timestamp);
                    if (!this.isRunning) break; 
                    this.accumulator -= Config.Game.tickTime;
                }

                if (!this.isRunning) return;

                const alpha = this.accumulator / Config.Game.tickTime;
                this._render(timestamp, alpha);
                this._updateStats(timestamp);
            }

            _serverTick(timestamp) {
                const inputs = {};
                inputs[this.playerId] = this.input.getInputState();
                
                this.prevCamera.x = this.camera.x;
                this.prevCamera.y = this.camera.y;

                const deadIds = this.server.tick(inputs, timestamp);
                
                if (deadIds.includes(this.playerId)) {
                    this.isRunning = false;
                    
                    // Fix: Clear canvas and hide ALL HUD elements so they don't freeze on screen
                    this.ctx.clearRect(0, 0, this.width, this.height);
                    
                    const uiIds = ['ui-desktop', 'ui-cashout', 'ui-leaderboard', 'ui-stats', 'mobile-cashout-btn', 'mobile-hint'];
                    uiIds.forEach(id => {
                        const el = document.getElementById(id);
                        if(el) el.style.display = 'none';
                    });

                    this.input.lockQ();
                    document.getElementById('main-menu-overlay').style.display = 'flex';
                    setTimeout(() => document.getElementById('main-menu-overlay').style.opacity = '1', 50);
                    this.server.removePlayer(this.playerId);
                    this.preview.start();
                    return;
                }

                const me = this.server.snakes.get(this.playerId);
                if (me) {
                    const sizeRatio = Config.Game.baseSnakeRadius / me.radius;
                    const influence = Math.pow(sizeRatio, 0.55);
                    const targetZoom = this.gameZoom * Math.max(0.6, Math.min(1.0, influence));
                    
                    this.renderZoom = Utils.lerp(this.renderZoom, targetZoom, 0.02);
                    
                    const vw = this.width / this.renderZoom; const vh = this.height / this.renderZoom;
                    const targetX = me.x - vw/2;
                    const targetY = me.y - vh/2;
                    
                    this.camera.x += (targetX - this.camera.x) * 0.1;
                    this.camera.y += (targetY - this.camera.y) * 0.1;
                }
            }

            _render(timestamp, alpha) {
                this.ctx.resetTransform();
                this.ctx.clearRect(0,0,this.width, this.height);

                // Interpolate camera between ticks
                const camX = Utils.lerp(this.prevCamera.x, this.camera.x, alpha);
                const camY = Utils.lerp(this.prevCamera.y, this.camera.y, alpha);

                this.ctx.save();
                this.ctx.scale(this.renderZoom, this.renderZoom);
                this.ctx.translate(-camX, -camY);

                const viewW = this.width / this.renderZoom;
                const viewH = this.height / this.renderZoom;
                const bounds = { x: camX, y: camY, w: viewW, h: viewH };

                this._drawBg(timestamp, camX, camY, viewW, viewH);

                const foods = OPT._collisionQueryBuffer;
                this.server.foodManager.grid.query(bounds, foods);
                for(const f of foods) {
                    const s = this.assets.foodSprites[f.spriteKey];
                    this.ctx.drawImage(s, f.x - s.width/2, f.y - s.height/2);
                }

                this._drawBoundary(timestamp, this.server.worldRadius);

                this.server.snakes.forEach(s => {
                    if (s.id === this.playerId) {
                        this.snakeRenderer.draw(this.ctx, s, alpha, bounds, this.highQuality);
                    }
                });

                this.ctx.restore();

                if(this.highQuality && this.assets.vignette) this.ctx.drawImage(this.assets.vignette, 0, 0);
                this._drawMinimap();
            }

            _drawBg(t, cx, cy, w, h) {
                this.ctx.fillStyle = '#050508'; this.ctx.fillRect(cx, cy, w, h);
                const r = Config.Background.hexSize; 
                const xs = 1.5 * r; 
                const ys = Math.sqrt(3) * r;
                
                const startCol = Math.floor(cx / xs) - 1; 
                const endCol = startCol + Math.ceil(w / xs) + 2;
                const startRow = Math.floor(cy / ys) - 1; 
                const endRow = startRow + Math.ceil(h / ys) + 2;

                const frameCount = this.assets.hexFrames.length;
                const animTime = t * Config.Background.animSpeed;

                for(let c = startCol; c < endCol; c++) {
                    for(let rw = startRow; rw < endRow; rw++) {
                        let x = c * xs; 
                        let y = rw * ys; 
                        if(c % 2 !== 0) y += ys / 2;
                        
                        const cacheKey = (c << 16) | (rw & 0xFFFF);
                        let phase = this._hexPhaseCache.get(cacheKey);
                        if (phase === undefined) {
                            phase = Math.abs(Utils.getPseudoRandom(c, rw) % (Math.PI * 2));
                            this._hexPhaseCache.set(cacheKey, phase);
                        }
                        
                        const norm = OPT.fastSinNorm(animTime + phase);
                        const idx = Math.floor(norm * (frameCount - 1));
                        
                        const img = this.assets.hexFrames[idx];
                        if(img) this.ctx.drawImage(img, (x - img.width/2) | 0, (y - img.height/2) | 0);
                    }
                }
            }

            _drawBoundary(t, r) {
                const ctx = this.ctx; const time = t*0.001;
                ctx.beginPath(); ctx.arc(0,0,r+2000,0,Math.PI*2); ctx.lineWidth=4000; ctx.strokeStyle="rgba(30,5,5,0.85)"; ctx.stroke();
                ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.lineWidth=40; ctx.strokeStyle="rgba(255,0,50,0.15)"; ctx.stroke();
                ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.lineWidth=8; ctx.strokeStyle="#ff0033"; ctx.stroke();
                ctx.save(); ctx.rotate(time*0.15); ctx.beginPath(); ctx.arc(0,0,r-20,0,Math.PI*2); ctx.lineWidth=3; ctx.strokeStyle="rgba(255,50,50,0.4)"; ctx.setLineDash([80,120]); ctx.stroke(); ctx.restore();
            }

            _drawMinimap() {
                const ctx = this.ctx;
                const m = Config.Minimap;
                const drawX = m.margin;
                const drawY = m.margin;
                
                const halfAssetSize = m.radius + m.margin;
                const mapCx = drawX + halfAssetSize;
                const mapCy = drawY + halfAssetSize;

                if (this.assets.minimapBg) {
                    ctx.drawImage(this.assets.minimapBg, drawX, drawY);
                }

                const p = this.server.snakes.get(this.playerId);
                if (!p) return;

                const nx = p.x / this.server.worldRadius;
                const ny = p.y / this.server.worldRadius;
                const d = Math.hypot(nx, ny);
                
                const dotRadius = 4;
                const renderRadius = m.radius - dotRadius - 2;

                let px, py;
                if (d > 1) {
                    const a = Math.atan2(ny, nx);
                    px = mapCx + Math.cos(a) * renderRadius;
                    py = mapCy + Math.sin(a) * renderRadius;
                } else {
                    px = mapCx + nx * renderRadius;
                    py = mapCy + ny * renderRadius;
                }

                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(px, py, dotRadius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.stroke();
            }

            _updateStats(t) {
                this.frameCount++;
                if(t - this.lastFpsTime >= 1000) {
                    document.getElementById('stat-fps').innerText = this.frameCount;
                    this.frameCount = 0; this.lastFpsTime = t;
                    const p = this.server.snakes.get(this.playerId);
                    if(p) this.leaderboard.update(t, p.score, p.nickname);
                }
            }
        }

        window.onload = () => { new ClientEngine(); };
    </script>
</body>
</html>
