<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wormoney v1.4 - High Performance</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            cursor: crosshair;
            touch-action: none; 
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1;
            touch-action: none; 
        }

        .ui-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 4;
            opacity: 0.5;
            font-size: 14px;
            color: #888;
            pointer-events: none;
        }

        /* --- CONTROL SELECTION MODAL --- */
        #control-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(5px);
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }

        .control-option {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .control-option:first-child {
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        .control-option:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .control-option:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .icon-area {
            font-size: 60px;
            margin-bottom: 20px;
        }

        .control-title {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .control-desc {
            font-size: 14px;
            color: #aaa;
            max-width: 250px;
            text-align: center;
            line-height: 1.5;
        }

        #or-divider {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            padding: 10px;
            border-radius: 50%;
            z-index: 2;
            color: #888;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        /* --- JOYSTICK UI --- */
        #joystick-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 5000;
            overflow: hidden;
            touch-action: none;
        }

        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            display: none; 
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
        }
        
        .tutorial-hint {
            position: absolute;
            top: 20%;
            width: 40%;
            text-align: center;
            color: rgba(255,255,255,0.3);
            font-size: 16px;
            pointer-events: none;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>
    <div class="ui-info" id="desktop-hint">LMB/RMB - Boost | Mouse - Move</div>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
        <div class="tutorial-hint" style="left: 5%; display: none;" id="hint-move">Touch & Hold<br>to Move</div>
        <div class="tutorial-hint" style="right: 5%; display: none;" id="hint-boost">Touch & Hold<br>to Boost</div>
    </div>

    <div id="control-modal">
        <div id="or-divider">OR</div>
        <div class="control-option" onclick="ControlManager.setMode('mobile')">
            <div class="icon-area">ðŸ“±</div>
            <div class="control-title">MOBILE</div>
            <div class="control-desc">
                Fast & Optimized<br>
                Static Background<br>
                Joystick Controls
            </div>
        </div>
        <div class="control-option" onclick="ControlManager.setMode('desktop')">
            <div class="icon-area">ðŸ’»</div>
            <div class="control-title">DESKTOP</div>
            <div class="control-desc">
                Full Visuals<br>
                Animated Background<br>
                Mouse Controls
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        
        const BG_CONFIG = {
            hexSize: 21.6,
            hexGap: 9, 
            hue: 215,
            saturation: 9,
            lightnessEdge: 2.5,
            centerMinL: 4.2,
            centerMaxL: 6.8,
            animSpeed: 0.001,
            centerL: 5.5, 
        };

        const GAME_CONFIG = {
            baseSpeed: 1.7,     
            boostSpeed: 3.3,     
            turnSpeed: 0.044, 
            targetLengthPx: 82, 
            radius: 9.2,
            skinColor: '#1a52bd', 
            renderGap: 1,
            eyeFollowSpeed: 0.15,
            targetVisibleArea: 300000 
        };

        const MINIMAP_CONFIG = {
            radius: 75,
            margin: 20,
            bgCenter: 'rgba(20, 20, 30, 0.4)', 
            bgEdge: 'rgba(10, 10, 20, 0.6)',
            borderColor: 'rgba(52, 0, 90, 0.9)', 
            playerColor: '#00d2ff'
        };

        const WORLD_RADIUS = 1500; 

        // --- INITIALIZATION ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 

        let gameState = {
            width: window.innerWidth,
            height: window.innerHeight,
            gameZoom: 1, 
            player: null,
            mouseX: 0,
            mouseY: 0,
            mouseDown: false,
            camera: { x: 0, y: 0 },
            globalTime: 0,
            currentWorldRadius: WORLD_RADIUS,
            highQuality: false 
        };

        // --- RENDER CACHE (PERFORMANCE OPTIMIZATION) ---
        const RenderCache = {
            mobileHex: null,
            minimapBg: null,
            vignette: null,
            hexOffsets: [],

            init: function() {
                // Pre-calculate hex geometry relative to center (0,0)
                const r = BG_CONFIG.hexSize;
                const drawR = Math.max(0, r - (BG_CONFIG.hexGap / 2));
                this.hexOffsets = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 180) * (60 * i);
                    this.hexOffsets.push({
                        x: drawR * Math.cos(angle),
                        y: drawR * Math.sin(angle)
                    });
                }

                this.updateMobileHex();
                this.updateMinimap();
            },

            updateMobileHex: function() {
                const r = BG_CONFIG.hexSize;
                const drawR = Math.max(0, r - (BG_CONFIG.hexGap / 2));
                const size = Math.ceil(drawR * 2 + 2);
                
                this.mobileHex = document.createElement('canvas');
                this.mobileHex.width = size;
                this.mobileHex.height = size;
                const mCtx = this.mobileHex.getContext('2d');
                const cx = size / 2;
                const cy = size / 2;

                const colorCenter = `hsl(${BG_CONFIG.hue}, ${BG_CONFIG.saturation}%, ${BG_CONFIG.centerL}%)`;
                const colorEdge = `hsl(${BG_CONFIG.hue}, ${BG_CONFIG.saturation}%, ${BG_CONFIG.lightnessEdge}%)`;

                mCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                     const angle = (Math.PI / 180) * (60 * i);
                     const px = cx + drawR * Math.cos(angle);
                     const py = cy + drawR * Math.sin(angle);
                     if (i===0) mCtx.moveTo(px, py); else mCtx.lineTo(px, py);
                }
                mCtx.closePath();

                const grad = mCtx.createRadialGradient(cx, cy, 0, cx, cy, drawR);
                grad.addColorStop(0, colorCenter);
                grad.addColorStop(1, colorEdge);
                mCtx.fillStyle = grad;
                mCtx.fill();
            },

            updateMinimap: function() {
                const mRadius = MINIMAP_CONFIG.radius;
                const mMargin = MINIMAP_CONFIG.margin;
                const size = (mRadius + mMargin) * 2;
                const centerX = size / 2;
                const centerY = size / 2;

                this.minimapBg = document.createElement('canvas');
                this.minimapBg.width = size;
                this.minimapBg.height = size;
                const mCtx = this.minimapBg.getContext('2d');

                const grad = mCtx.createRadialGradient(
                    centerX - mRadius * 0.3, centerY - mRadius * 0.3, mRadius * 0.1,
                    centerX, centerY, mRadius
                );
                grad.addColorStop(0, MINIMAP_CONFIG.bgCenter);
                grad.addColorStop(1, MINIMAP_CONFIG.bgEdge);

                mCtx.beginPath();
                mCtx.arc(centerX, centerY, mRadius, 0, Math.PI * 2);
                mCtx.clip(); 
                mCtx.fillStyle = grad;
                mCtx.fill(); 

                // Border
                mCtx.beginPath();
                mCtx.arc(centerX, centerY, mRadius, 0, Math.PI * 2);
                mCtx.lineWidth = 3;
                mCtx.strokeStyle = MINIMAP_CONFIG.borderColor;
                mCtx.stroke();
            },

            updateVignette: function(w, h) {
                if (!gameState.highQuality) {
                    this.vignette = null;
                    return;
                }
                this.vignette = document.createElement('canvas');
                this.vignette.width = w;
                this.vignette.height = h;
                const vCtx = this.vignette.getContext('2d');
                
                const vRadius = Math.hypot(w/2, h/2); 
                const vGrad = vCtx.createRadialGradient(
                    w / 2, h / 2, vRadius * 0.4, 
                    w / 2, h / 2, vRadius
                );
                vGrad.addColorStop(0, 'rgba(0,0,0,0)');
                vGrad.addColorStop(1, 'rgba(0,0,0,0.95)');
                
                vCtx.fillStyle = vGrad;
                vCtx.fillRect(0, 0, w, h);
            }
        };

        gameState.mouseX = gameState.width / 2;
        gameState.mouseY = gameState.height / 2;

        window.addEventListener('contextmenu', e => e.preventDefault());

        function lerpAngle(a, b, t) {
            let diff = b - a;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return a + diff * t;
        }

        function getLerpFactor(baseRate, timeScale) {
            return 1 - Math.pow(1 - baseRate, timeScale);
        }
        
        function getPseudoRandom(x, y) {
            return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
        }

        // --- SNAKE CLASS ---
        class Snake {
            constructor() {
                this.headSprite = this.createHeadBase(GAME_CONFIG.skinColor);
                this.reset();
                this.blinkTimer = 0;
                this.blinkState = 0; 
                this.eyeOpenness = 1.0;
            }

            reset() {
                this.x = 0; 
                this.y = 0;
                this.angle = -Math.PI / 2;
                this.targetAngle = this.angle;
                this.lookAngle = 0;
                this.radius = GAME_CONFIG.radius;
                
                this.path = [];
                const startPoints = 50; 
                for(let i=0; i < startPoints; i++) {
                    this.path.push({x: this.x, y: this.y + (i * 2)});
                }
                
                this.boosting = false;
                this.dashOffset = 0; 
                this.blinkTimer = Math.random() * 200 + 100;
                this.eyeOpenness = 1.0;
            }

            createHeadBase(colorHex) {
                const r = GAME_CONFIG.radius;
                const size = r * 2 + 4; 
                const c = document.createElement('canvas');
                c.width = size;
                c.height = size;
                const cx = c.getContext('2d');
                const center = size / 2;

                cx.fillStyle = colorHex;
                cx.beginPath();
                cx.arc(center, center, r, 0, Math.PI*2);
                cx.fill();

                const grad = cx.createRadialGradient(
                    center - r*0.3, center - r*0.3, 0,
                    center, center, r
                );
                grad.addColorStop(0, 'rgba(255,255,255,0.25)'); 
                grad.addColorStop(1, 'rgba(255,255,255,0)');

                cx.fillStyle = grad;
                cx.beginPath();
                cx.arc(center, center, r, 0, Math.PI*2);
                cx.fill();

                return c;
            }

            update(timeScale) {
                const screenCenterX = gameState.width / 2;
                const screenCenterY = gameState.height / 2;
                const dx = gameState.mouseX - screenCenterX;
                const dy = gameState.mouseY - screenCenterY;
                
                this.targetAngle = Math.atan2(dy, dx);
                this.boosting = gameState.mouseDown;
                
                const turnRate = getLerpFactor(GAME_CONFIG.turnSpeed, timeScale);
                this.angle = lerpAngle(this.angle, this.targetAngle, turnRate);

                if (gameState.highQuality) {
                    let desiredLookAngle = this.targetAngle - this.angle;
                    while (desiredLookAngle > Math.PI) desiredLookAngle -= Math.PI * 2;
                    while (desiredLookAngle < -Math.PI) desiredLookAngle += Math.PI * 2;
                    const maxEyeAngle = Math.PI / 2.2; 
                    if (desiredLookAngle > maxEyeAngle) desiredLookAngle = maxEyeAngle;
                    if (desiredLookAngle < -maxEyeAngle) desiredLookAngle = -maxEyeAngle;

                    const eyeRate = getLerpFactor(GAME_CONFIG.eyeFollowSpeed, timeScale);
                    this.lookAngle = lerpAngle(this.lookAngle, desiredLookAngle, eyeRate);
                    
                    this.blinkTimer -= timeScale;
                    const blinkSpeed = 10; 
                    if (this.blinkState === 0) { 
                        if (this.blinkTimer <= 0) { this.blinkState = 1; this.blinkTimer = blinkSpeed; }
                        this.eyeOpenness = 1.0;
                    } else if (this.blinkState === 1) { 
                        if (this.blinkTimer <= 0) { this.blinkState = 2; this.blinkTimer = blinkSpeed; }
                        this.eyeOpenness = Math.max(0, this.blinkTimer / blinkSpeed);
                    } else if (this.blinkState === 2) { 
                        if (this.blinkTimer <= 0) { this.blinkState = 0; this.blinkTimer = Math.random() * 200 + 150; }
                        this.eyeOpenness = 1.0 - Math.max(0, this.blinkTimer / blinkSpeed);
                    }
                }

                let currentSpeed = this.boosting ? GAME_CONFIG.boostSpeed : GAME_CONFIG.baseSpeed;
                currentSpeed *= timeScale;

                this.dashOffset -= currentSpeed * 1.5;

                let nextX = this.x + Math.cos(this.angle) * currentSpeed;
                let nextY = this.y + Math.sin(this.angle) * currentSpeed;

                const distFromCenter = Math.hypot(nextX, nextY);
                const limit = gameState.currentWorldRadius - this.radius; 

                if (distFromCenter > limit) {
                    this.reset();
                    return; 
                }

                this.x = nextX;
                this.y = nextY;

                this.path.unshift({x: this.x, y: this.y});
                
                let accumulatedLen = 0;
                
                for (let i = 0; i < this.path.length - 1; i++) {
                    const p1 = this.path[i];
                    const p2 = this.path[i+1];
                    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    
                    if (accumulatedLen + dist > GAME_CONFIG.targetLengthPx) {
                        const remaining = GAME_CONFIG.targetLengthPx - accumulatedLen;
                        const ratio = remaining / dist;
                        
                        p2.x = p1.x + (p2.x - p1.x) * ratio;
                        p2.y = p1.y + (p2.y - p1.y) * ratio;
                        
                        this.path.length = i + 2;
                        break;
                    }
                    accumulatedLen += dist;
                }
            }

            draw(ctx) {
                if (this.path.length < 2) return;

                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(this.path[0].x + 4, this.path[0].y + 6); 
                for (let i = 1; i < this.path.length; i++) {
                    ctx.lineTo(this.path[i].x + 4, this.path[i].y + 6);
                }
                ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
                ctx.lineWidth = this.radius * 2 + 2;
                if (gameState.highQuality) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = "rgba(0,0,0,0.5)";
                }
                ctx.stroke();
                
                if (gameState.highQuality) {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = "transparent";
                }

                if (this.boosting) {
                    ctx.beginPath();
                    ctx.moveTo(this.path[0].x, this.path[0].y);
                    for (let i = 1; i < this.path.length; i++) {
                        ctx.lineTo(this.path[i].x, this.path[i].y);
                    }
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.lineWidth = this.radius * 2 + 6;
                    if (gameState.highQuality) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = "white";
                    }
                    ctx.stroke();
                    if (gameState.highQuality) ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.moveTo(this.path[0].x, this.path[0].y);
                for (let i = 1; i < this.path.length; i++) {
                    ctx.lineTo(this.path[i].x, this.path[i].y);
                }
                ctx.strokeStyle = GAME_CONFIG.skinColor;
                ctx.lineWidth = this.radius * 2;
                ctx.stroke();

                const headOffset = this.headSprite.width / 2;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.drawImage(this.headSprite, -headOffset, -headOffset);

                if (gameState.highQuality) {
                    this.drawDynamicEyes(ctx);
                } else {
                    this.drawStaticEyes(ctx);
                }
                ctx.restore();
            }

            drawStaticEyes(ctx) {
                const drawStaticEye = (side) => {
                    const eyeX = this.radius * 0.4;
                    const eyeY = (side === 'left' ? -1 : 1) * (this.radius * 0.55);
                    const eyeRadius = this.radius * 0.42;

                    ctx.save();
                    ctx.translate(eyeX, eyeY);
                    
                    ctx.fillStyle = '#f0f0f0';
                    ctx.beginPath();
                    ctx.arc(0, 0, eyeRadius, 0, Math.PI*2);
                    ctx.fill();

                    const pupilSize = eyeRadius * 0.6;
                    const pDx = eyeRadius * 0.2; 
                    
                    ctx.fillStyle = "#111"; 
                    ctx.beginPath();
                    ctx.arc(pDx, 0, pupilSize, 0, Math.PI*2);
                    ctx.fill();

                    ctx.fillStyle = "rgba(255,255,255,0.9)";
                    ctx.beginPath();
                    ctx.arc(pDx - pupilSize*0.3, -pupilSize*0.3, pupilSize*0.25, 0, Math.PI*2);
                    ctx.fill();

                    ctx.restore();
                };
                drawStaticEye('left');
                drawStaticEye('right');
            }

            drawDynamicEyes(ctx) {
                const drawEye = (side) => {
                    const eyeX = this.radius * 0.4;
                    const eyeY = (side === 'left' ? -1 : 1) * (this.radius * 0.55);
                    const eyeRadius = this.radius * 0.42;

                    if (this.eyeOpenness < 0.1) {
                        ctx.save();
                        ctx.translate(eyeX, eyeY);
                        ctx.beginPath();
                        ctx.moveTo(-eyeRadius, 0);
                        ctx.lineTo(eyeRadius, 0);
                        ctx.lineWidth = 1.5;
                        ctx.strokeStyle = "#333";
                        ctx.stroke();
                        ctx.restore();
                        return;
                    }

                    ctx.save();
                    ctx.translate(eyeX, eyeY);
                    
                    const blinkScale = this.eyeOpenness;
                    ctx.scale(1, blinkScale);

                    const scleraGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, eyeRadius);
                    scleraGrad.addColorStop(0, '#ffffff');
                    scleraGrad.addColorStop(1, '#e6e6e6');
                    ctx.fillStyle = scleraGrad;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, eyeRadius, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = "rgba(0,0,0,0.15)";
                    ctx.lineWidth = 0.5;
                    ctx.stroke();

                    const pupilSize = eyeRadius * 0.55;
                    const maxLookAngle = Math.PI / 2.2;
                    const turnIntensity = Math.min(1, Math.abs(this.lookAngle) / maxLookAngle);
                    const dynamicRange = 0.3 + (0.15 * turnIntensity);
                    const pupilRange = eyeRadius * dynamicRange;
                    
                    const pDx = Math.cos(this.lookAngle) * pupilRange;
                    const pDy = Math.sin(this.lookAngle) * pupilRange;

                    ctx.fillStyle = "#111"; 
                    ctx.beginPath();
                    ctx.arc(pDx, pDy, pupilSize, 0, Math.PI*2);
                    ctx.fill();

                    if (this.eyeOpenness > 0.4) {
                        ctx.fillStyle = "rgba(255,255,255,0.9)";
                        ctx.beginPath();
                        ctx.arc(pDx - pupilSize*0.3, pDy - pupilSize*0.3, pupilSize*0.25, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                };
                drawEye('left');
                drawEye('right');
            }
        }

        // --- BACKGROUND (OPTIMIZED) ---
        function drawBackground(ctx, camX, camY, timestamp) {
            const viewportW = gameState.width / gameState.gameZoom;
            const viewportH = gameState.height / gameState.gameZoom;

            ctx.fillStyle = '#000000'; 
            ctx.fillRect(camX, camY, viewportW, viewportH);

            const r = BG_CONFIG.hexSize;
            const xStep = 1.5 * r;
            const yStep = Math.sqrt(3) * r;

            const startCol = Math.floor(camX / xStep) - 1;
            const startRow = Math.floor(camY / yStep) - 1;
            const cols = Math.ceil(viewportW / xStep) + 2;
            const rows = Math.ceil(viewportH / yStep) + 2;

            const drawR = Math.max(0, r - (BG_CONFIG.hexGap / 2));
            const useCache = !gameState.highQuality && RenderCache.mobileHex;
            const offsets = RenderCache.hexOffsets;

            for (let col = startCol; col < startCol + cols; col++) {
                for (let row = startRow; row < startRow + rows; row++) {
                    let hexWorldX = col * xStep;
                    let hexWorldY = row * yStep;
                    if (col % 2 !== 0) hexWorldY += yStep / 2;

                    if (useCache) {
                        // High Performance Blitting for Mobile
                        const size = RenderCache.mobileHex.width;
                        ctx.drawImage(RenderCache.mobileHex, hexWorldX - size/2, hexWorldY - size/2);
                    } else {
                        // High Quality Animated for PC
                        const phase = Math.abs(getPseudoRandom(col, row) % (Math.PI * 2));
                        const sinVal = Math.sin(timestamp * BG_CONFIG.animSpeed + phase);
                        const normVal = (sinVal + 1) / 2;
                        const currentCenterL = BG_CONFIG.centerMinL + (BG_CONFIG.centerMaxL - BG_CONFIG.centerMinL) * normVal;
                        const colorCenter = `hsl(${BG_CONFIG.hue}, ${BG_CONFIG.saturation}%, ${currentCenterL}%)`;
                        const colorEdge = `hsl(${BG_CONFIG.hue}, ${BG_CONFIG.saturation}%, ${BG_CONFIG.lightnessEdge}%)`;

                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            // Using pre-calculated offsets to avoid 6x trig calls per hex
                            const px = hexWorldX + offsets[i].x;
                            const py = hexWorldY + offsets[i].y;
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();

                        const gradient = ctx.createRadialGradient(hexWorldX, hexWorldY, 0, hexWorldX, hexWorldY, drawR);
                        gradient.addColorStop(0, colorCenter);
                        gradient.addColorStop(1, colorEdge);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    }
                }
            }
        }

        // --- CONTROL MANAGER ---
        const ControlManager = {
            mode: null, 
            joystickData: {
                active: false,
                id: null,
                origin: { x: 0, y: 0 },
                current: { x: 0, y: 0 },
                radius: 40 
            },
            boostPointers: new Set(),

            setMode: function(mode) {
                this.mode = mode;
                document.getElementById('control-modal').style.display = 'none';

                if (mode === 'desktop') {
                    // ENABLE HIGH QUALITY
                    gameState.highQuality = true;
                    this.initDesktop();
                    document.getElementById('desktop-hint').style.display = 'block';
                    // Re-generate vignette for PC resolution immediately
                    RenderCache.updateVignette(gameState.width, gameState.height);
                } else if (mode === 'mobile') {
                    // DISABLE HIGH QUALITY (Optimized)
                    gameState.highQuality = false;
                    this.initMobile();
                    document.getElementById('desktop-hint').style.display = 'none';
                    document.getElementById('hint-move').style.display = 'block';
                    document.getElementById('hint-boost').style.display = 'block';
                }
            },

            initDesktop: function() {
                window.addEventListener('mousemove', e => {
                    gameState.mouseX = e.clientX;
                    gameState.mouseY = e.clientY;
                });
                window.addEventListener('mousedown', () => gameState.mouseDown = true);
                window.addEventListener('mouseup', () => gameState.mouseDown = false);
            },

            initMobile: function() {
                const joystickBase = document.getElementById('joystick-base');
                const joystickStick = document.getElementById('joystick-stick');
                
                const onPointerDown = (e) => {
                    e.preventDefault(); 
                    const x = e.clientX;
                    const y = e.clientY;

                    if (canvas.setPointerCapture) {
                        try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
                    }

                    if (x < window.innerWidth / 2) {
                        if (this.joystickData.active) {
                            this.joystickData.active = false;
                            joystickBase.style.display = 'none';
                        }
                        this.joystickData.active = true;
                        this.joystickData.id = e.pointerId; 
                        this.joystickData.origin = { x, y };
                        this.joystickData.current = { x, y };

                        joystickBase.style.display = 'block';
                        joystickBase.style.left = x + 'px';
                        joystickBase.style.top = y + 'px';
                        joystickStick.style.transform = `translate(-50%, -50%)`;
                        document.getElementById('hint-move').style.display = 'none';
                    } else {
                        this.boostPointers.add(e.pointerId);
                        gameState.mouseDown = true;
                        document.getElementById('hint-boost').style.display = 'none';
                    }
                };

                const onPointerMove = (e) => {
                    e.preventDefault();
                    if (this.joystickData.active && e.pointerId === this.joystickData.id) {
                        const dx = e.clientX - this.joystickData.origin.x;
                        const dy = e.clientY - this.joystickData.origin.y;
                        const distance = Math.hypot(dx, dy);
                        const angle = Math.atan2(dy, dx);
                        const clampedDist = Math.min(distance, this.joystickData.radius);
                        const stickX = Math.cos(angle) * clampedDist;
                        const stickY = Math.sin(angle) * clampedDist;

                        joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;
                        const projectionDist = 500; 
                        gameState.mouseX = (gameState.width / 2) + Math.cos(angle) * projectionDist;
                        gameState.mouseY = (gameState.height / 2) + Math.sin(angle) * projectionDist;
                    }
                };

                const onPointerUp = (e) => {
                    e.preventDefault();
                    if (this.joystickData.active && e.pointerId === this.joystickData.id) {
                        this.joystickData.active = false;
                        this.joystickData.id = null;
                        joystickBase.style.display = 'none';
                        if (canvas.releasePointerCapture) { try { canvas.releasePointerCapture(e.pointerId); } catch(e){} }
                    }
                    if (this.boostPointers.has(e.pointerId)) {
                        this.boostPointers.delete(e.pointerId);
                        if (this.boostPointers.size === 0) gameState.mouseDown = false;
                        if (canvas.releasePointerCapture) { try { canvas.releasePointerCapture(e.pointerId); } catch(e){} }
                    }
                };

                window.addEventListener('pointerdown', onPointerDown, { passive: false });
                window.addEventListener('pointermove', onPointerMove, { passive: false });
                window.addEventListener('pointerup', onPointerUp, { passive: false });
                window.addEventListener('pointercancel', onPointerUp, { passive: false });
                window.addEventListener('pointerleave', onPointerUp, { passive: false });
                window.addEventListener('contextmenu', e => e.preventDefault());
            }
        };

        // --- GAME LOOP ---
        function updateSize() {
            gameState.width = window.innerWidth;
            gameState.height = window.innerHeight;
            canvas.width = gameState.width;
            canvas.height = gameState.height;
            const currentArea = gameState.width * gameState.height;
            gameState.gameZoom = Math.sqrt(currentArea / GAME_CONFIG.targetVisibleArea);
            gameState.gameZoom = Math.max(0.1, Math.min(20.0, gameState.gameZoom));

            // Update cached vignette if screen resizes (Desktop only)
            RenderCache.updateVignette(gameState.width, gameState.height);
        }

        function initGame() {
            // Init Renderer Caches before anything else
            RenderCache.init();
            
            updateSize();
            gameState.player = new Snake();
            window.addEventListener('resize', updateSize);
        }

        let lastTime = 0;

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (deltaTime > 100) deltaTime = 100;
            const timeScale = deltaTime / 16.667;

            gameState.globalTime = timestamp;

            const pulse = Math.sin(timestamp * 0.002); 
            const dynamicRadius = WORLD_RADIUS + (pulse * 40); 
            gameState.currentWorldRadius = dynamicRadius;

            if (gameState.player) {
                gameState.player.update(timeScale);
                const viewW = gameState.width / gameState.gameZoom;
                const viewH = gameState.height / gameState.gameZoom;
                gameState.camera.x = gameState.player.x - viewW / 2;
                gameState.camera.y = gameState.player.y - viewH / 2;
            }

            ctx.resetTransform(); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. GAME WORLD
            ctx.scale(gameState.gameZoom, gameState.gameZoom);
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            drawBackground(ctx, gameState.camera.x, gameState.camera.y, timestamp);

            // Boundary
            const zoneThickness = 400; 
            const grad = ctx.createRadialGradient(0, 0, dynamicRadius, 0, 0, dynamicRadius + zoneThickness);
            grad.addColorStop(0, 'rgba(255, 50, 50, 0.6)');      
            grad.addColorStop(0.3, 'rgba(255, 0, 0, 0.2)');     
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');          

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius + zoneThickness, 0, Math.PI * 2); 
            ctx.arc(0, 0, dynamicRadius, 0, Math.PI * 2, true);           
            ctx.fill();

            ctx.lineWidth = 4;
            ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 + pulse * 0.2})`;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = "rgba(255, 50, 50, 0.15)";
            ctx.font = "200px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("âœ•", 0, 0); 

            if (gameState.player) {
                gameState.player.draw(ctx);
            }

            // --- INTERFACE LAYER ---
            ctx.resetTransform();
            
            // 2. VIGNETTE (Cached Fill-Rate Optimization)
            if (gameState.highQuality && RenderCache.vignette) {
                ctx.drawImage(RenderCache.vignette, 0, 0);
            }
            
            // 3. MINIMAP (Cached Background Optimization)
            drawMinimap(ctx);

            requestAnimationFrame(gameLoop);
        }
        
        function drawMinimap(ctx) {
            const mRadius = MINIMAP_CONFIG.radius;
            const mMargin = MINIMAP_CONFIG.margin;
            
            const centerX = mMargin + mRadius;
            const centerY = mMargin + mRadius;

            // Draw Cached Background
            if (RenderCache.minimapBg) {
                // Determine top-left corner of the minimap image
                const drawX = centerX - (mRadius + mMargin);
                const drawY = centerY - (mRadius + mMargin);
                ctx.drawImage(RenderCache.minimapBg, drawX, drawY);
            }

            ctx.save();
            ctx.resetTransform();
            
            // Re-clip for player drawing (safety, though drawing inside the bg rect is usually fine)
            // For optimization, we skip clipping if we trust the player bounds.
            // But we need to calculate player position relative to minimap center.
            if (gameState.player) {
                const normX = gameState.player.x / WORLD_RADIUS;
                const normY = gameState.player.y / WORLD_RADIUS;
                const dist = Math.hypot(normX, normY);
                let pX, pY;
                if (dist > 1) {
                    const angle = Math.atan2(normY, normX);
                    pX = centerX + Math.cos(angle) * mRadius;
                    pY = centerY + Math.sin(angle) * mRadius;
                } else {
                    pX = centerX + normX * mRadius;
                    pY = centerY + normY * mRadius;
                }
                ctx.fillStyle = MINIMAP_CONFIG.playerColor;
                ctx.beginPath();
                ctx.arc(pX, pY, 3.5, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        initGame();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
