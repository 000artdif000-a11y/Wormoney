<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wormoney v1.1</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            cursor: crosshair;
            /* Prevents default touch actions like scroll/zoom on mobile */
            touch-action: none; 
            -webkit-touch-callout: none;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .ui-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 4;
            opacity: 0.5;
            font-size: 14px;
            color: #888;
            pointer-events: none;
        }

        /* --- CONTROL SELECTION MODAL --- */
        #control-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: flex;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            font-family: 'Segoe UI', sans-serif;
        }

        .control-option {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .control-option:first-child {
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        .control-option:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .control-option:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .icon-area {
            font-size: 60px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.2));
        }

        .control-title {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .control-desc {
            font-size: 14px;
            color: #aaa;
            max-width: 250px;
            text-align: center;
            line-height: 1.5;
        }

        /* Visual Separator Text */
        #or-divider {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #222;
            padding: 10px;
            border-radius: 50%;
            z-index: 2;
            color: #888;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        /* --- JOYSTICK UI --- */
        #joystick-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let touches pass through to document handler */
            z-index: 5000;
            overflow: hidden;
        }

        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            display: none; /* Hidden by default */
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .tutorial-hint {
            position: absolute;
            top: 20%;
            width: 40%;
            text-align: center;
            color: rgba(255,255,255,0.3);
            font-size: 16px;
            pointer-events: none;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="game-canvas"></canvas>
    
    <!-- Original UI Info (Visible in Desktop Mode mostly) -->
    <div class="ui-info" id="desktop-hint">LMB/RMB - Boost | Mouse - Move</div>

    <!-- Joystick UI Container -->
    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
        <!-- Mobile Hints -->
        <div class="tutorial-hint" style="left: 5%; display: none;" id="hint-move">Touch & Hold<br>to Move</div>
        <div class="tutorial-hint" style="right: 5%; display: none;" id="hint-boost">Touch & Hold<br>to Boost</div>
    </div>

    <!-- Control Selection Modal -->
    <div id="control-modal">
        <div id="or-divider">OR</div>
        
        <!-- Mobile Option -->
        <div class="control-option" onclick="ControlManager.setMode('mobile')">
            <div class="icon-area">ðŸ“±</div>
            <div class="control-title">MOBILE</div>
            <div class="control-desc">
                Left Side: Dynamic Joystick<br>
                Right Side: Hold to Boost
            </div>
        </div>

        <!-- Desktop Option -->
        <div class="control-option" onclick="ControlManager.setMode('desktop')">
            <div class="icon-area">ðŸ’»</div>
            <div class="control-title">DESKTOP</div>
            <div class="control-desc">
                Mouse to Steer<br>
                Click to Boost
            </div>
        </div>
    </div>

    <script>
        // --- ÐšÐžÐÐ¤Ð˜Ð“Ð£Ð ÐÐ¦Ð˜Ð¯ ---
        
        const BG_CONFIG = {
            hexSize: 21.6,
            hexGap: 9, 
            hue: 215,
            saturation: 9,
            lightnessEdge: 2.5,
            centerMinL: 4.2,
            centerMaxL: 6.8,
            animSpeed: 0.001
        };

        const GAME_CONFIG = {
            baseSpeed: 1.7,     
            boostSpeed: 3.3,     
            turnSpeed: 0.044, 
            targetLengthPx: 82, 
            radius: 9.2,
            skinColor: '#1a52bd', 
            renderGap: 1, 
            eyeFollowSpeed: 0.15,
            targetVisibleArea: 300000 
        };

        const MINIMAP_CONFIG = {
            radius: 75,
            margin: 20,
            bgCenter: 'rgba(20, 20, 30, 0.4)', 
            bgEdge: 'rgba(10, 10, 20, 0.6)',
            borderColor: 'rgba(52, 0, 90, 0.9)', 
            playerColor: '#00d2ff'
        };

        const WORLD_RADIUS = 1500; 

        // --- Ð˜ÐÐ˜Ð¦Ð˜ÐÐ›Ð˜Ð—ÐÐ¦Ð˜Ð¯ ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 

        let gameState = {
            width: window.innerWidth,
            height: window.innerHeight,
            gameZoom: 1, 
            player: null,
            mouseX: 0,
            mouseY: 0,
            mouseDown: false,
            camera: { x: 0, y: 0 },
            globalTime: 0,
            currentWorldRadius: WORLD_RADIUS
        };

        // Initialize mouse in center to prevent instant turning on load
        gameState.mouseX = gameState.width / 2;
        gameState.mouseY = gameState.height / 2;

        window.addEventListener('contextmenu', e => e.preventDefault());

        function lerpAngle(a, b, t) {
            let diff = b - a;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return a + diff * t;
        }

        function getLerpFactor(baseRate, timeScale) {
            return 1 - Math.pow(1 - baseRate, timeScale);
        }

        function getPseudoRandom(x, y) {
            return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
        }

        // --- Ð—ÐœÐ•Ð™ÐšÐ ---
        class Snake {
            constructor() {
                this.headSprite = this.createHeadBase(GAME_CONFIG.skinColor);
                this.reset();
                this.blinkTimer = 0;
                this.blinkState = 0; 
                this.eyeOpenness = 1.0;
            }

            reset() {
                this.x = 0; 
                this.y = 0;
                this.angle = -Math.PI / 2;
                this.targetAngle = this.angle;
                this.lookAngle = 0;
                this.radius = GAME_CONFIG.radius;
                
                this.path = [];
                const startPoints = 50; 
                for(let i=0; i < startPoints; i++) {
                    this.path.push({x: this.x, y: this.y + (i * 2)});
                }
                
                this.boosting = false;
                this.dashOffset = 0; 
                this.blinkTimer = Math.random() * 200 + 100;
                this.eyeOpenness = 1.0;
            }

            createHeadBase(colorHex) {
                const r = GAME_CONFIG.radius;
                const size = r * 2 + 4; 
                const c = document.createElement('canvas');
                c.width = size;
                c.height = size;
                const cx = c.getContext('2d');
                const center = size / 2;

                cx.fillStyle = colorHex;
                cx.beginPath();
                cx.arc(center, center, r, 0, Math.PI*2);
                cx.fill();

                const grad = cx.createRadialGradient(
                    center - r*0.3, center - r*0.3, 0,
                    center, center, r
                );
                grad.addColorStop(0, 'rgba(255,255,255,0.25)'); 
                grad.addColorStop(1, 'rgba(255,255,255,0)');

                cx.fillStyle = grad;
                cx.beginPath();
                cx.arc(center, center, r, 0, Math.PI*2);
                cx.fill();

                return c;
            }

            update(timeScale) {
                const screenCenterX = gameState.width / 2;
                const screenCenterY = gameState.height / 2;
                // Calculate direction based on gameState.mouseX/Y relative to screen center
                const dx = gameState.mouseX - screenCenterX;
                const dy = gameState.mouseY - screenCenterY;
                
                this.targetAngle = Math.atan2(dy, dx);
                this.boosting = gameState.mouseDown;
                
                const turnRate = getLerpFactor(GAME_CONFIG.turnSpeed, timeScale);
                this.angle = lerpAngle(this.angle, this.targetAngle, turnRate);

                let desiredLookAngle = this.targetAngle - this.angle;
                while (desiredLookAngle > Math.PI) desiredLookAngle -= Math.PI * 2;
                while (desiredLookAngle < -Math.PI) desiredLookAngle += Math.PI * 2;
                const maxEyeAngle = Math.PI / 2.2; 
                if (desiredLookAngle > maxEyeAngle) desiredLookAngle = maxEyeAngle;
                if (desiredLookAngle < -maxEyeAngle) desiredLookAngle = -maxEyeAngle;

                const eyeRate = getLerpFactor(GAME_CONFIG.eyeFollowSpeed, timeScale);
                this.lookAngle = lerpAngle(this.lookAngle, desiredLookAngle, eyeRate);

                let currentSpeed = this.boosting ? GAME_CONFIG.boostSpeed : GAME_CONFIG.baseSpeed;
                currentSpeed *= timeScale;

                this.dashOffset -= currentSpeed * 1.5;

                let nextX = this.x + Math.cos(this.angle) * currentSpeed;
                let nextY = this.y + Math.sin(this.angle) * currentSpeed;

                const distFromCenter = Math.hypot(nextX, nextY);
                const limit = gameState.currentWorldRadius - this.radius; 

                if (distFromCenter > limit) {
                    this.reset();
                    return; 
                }

                this.x = nextX;
                this.y = nextY;

                this.path.unshift({x: this.x, y: this.y});
                
                let accumulatedLen = 0;
                
                for (let i = 0; i < this.path.length - 1; i++) {
                    const p1 = this.path[i];
                    const p2 = this.path[i+1];
                    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    
                    if (accumulatedLen + dist > GAME_CONFIG.targetLengthPx) {
                        const remaining = GAME_CONFIG.targetLengthPx - accumulatedLen;
                        const ratio = remaining / dist;
                        
                        p2.x = p1.x + (p2.x - p1.x) * ratio;
                        p2.y = p1.y + (p2.y - p1.y) * ratio;
                        
                        this.path.length = i + 2;
                        break;
                    }
                    accumulatedLen += dist;
                }

                this.blinkTimer -= timeScale;
                const blinkSpeed = 10; 
                if (this.blinkState === 0) { 
                    if (this.blinkTimer <= 0) { this.blinkState = 1; this.blinkTimer = blinkSpeed; }
                    this.eyeOpenness = 1.0;
                } else if (this.blinkState === 1) { 
                    if (this.blinkTimer <= 0) { this.blinkState = 2; this.blinkTimer = blinkSpeed; }
                    this.eyeOpenness = Math.max(0, this.blinkTimer / blinkSpeed);
                } else if (this.blinkState === 2) { 
                    if (this.blinkTimer <= 0) { this.blinkState = 0; this.blinkTimer = Math.random() * 200 + 150; }
                    this.eyeOpenness = 1.0 - Math.max(0, this.blinkTimer / blinkSpeed);
                }
            }

            draw(ctx) {
                if (this.path.length < 2) return;

                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // 1. Shadow
                ctx.beginPath();
                ctx.moveTo(this.path[0].x + 4, this.path[0].y + 6); 
                for (let i = 1; i < this.path.length; i++) {
                    ctx.lineTo(this.path[i].x + 4, this.path[i].y + 6);
                }
                ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
                ctx.lineWidth = this.radius * 2 + 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.shadowColor = "transparent";

                // 2. Glow when boosting
                if (this.boosting) {
                    ctx.beginPath();
                    ctx.moveTo(this.path[0].x, this.path[0].y);
                    for (let i = 1; i < this.path.length; i++) {
                        ctx.lineTo(this.path[i].x, this.path[i].y);
                    }
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.lineWidth = this.radius * 2 + 6;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = "white";
                    ctx.stroke();
                    ctx.shadowBlur = 0; 
                }

                // 3. Main body
                ctx.beginPath();
                ctx.moveTo(this.path[0].x, this.path[0].y);
                for (let i = 1; i < this.path.length; i++) {
                    ctx.lineTo(this.path[i].x, this.path[i].y);
                }
                ctx.strokeStyle = GAME_CONFIG.skinColor;
                ctx.lineWidth = this.radius * 2;
                ctx.stroke();

                // 4. Head
                const headOffset = this.headSprite.width / 2;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.drawImage(this.headSprite, -headOffset, -headOffset);

                // --- EYES ---
                const drawEye = (side) => {
                    const eyeX = this.radius * 0.4;
                    const eyeY = (side === 'left' ? -1 : 1) * (this.radius * 0.55);
                    const eyeRadius = this.radius * 0.42;

                    if (this.eyeOpenness < 0.1) {
                        ctx.save();
                        ctx.translate(eyeX, eyeY);
                        ctx.beginPath();
                        ctx.moveTo(-eyeRadius, 0);
                        ctx.lineTo(eyeRadius, 0);
                        ctx.lineWidth = 1.5;
                        ctx.strokeStyle = "#333";
                        ctx.stroke();
                        ctx.restore();
                        return;
                    }

                    ctx.save();
                    ctx.translate(eyeX, eyeY);
                    
                    const blinkScale = this.eyeOpenness;
                    ctx.scale(1, blinkScale);

                    const scleraGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, eyeRadius);
                    scleraGrad.addColorStop(0, '#ffffff');
                    scleraGrad.addColorStop(1, '#e6e6e6');
                    ctx.fillStyle = scleraGrad;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, eyeRadius, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = "rgba(0,0,0,0.15)";
                    ctx.lineWidth = 0.5;
                    ctx.stroke();

                    const pupilSize = eyeRadius * 0.55;
                    const maxLookAngle = Math.PI / 2.2;
                    const turnIntensity = Math.min(1, Math.abs(this.lookAngle) / maxLookAngle);
                    const dynamicRange = 0.3 + (0.15 * turnIntensity);
                    const pupilRange = eyeRadius * dynamicRange;
                    
                    const pDx = Math.cos(this.lookAngle) * pupilRange;
                    const pDy = Math.sin(this.lookAngle) * pupilRange;

                    ctx.fillStyle = "#111"; 
                    ctx.beginPath();
                    ctx.arc(pDx, pDy, pupilSize, 0, Math.PI*2);
                    ctx.fill();

                    if (this.eyeOpenness > 0.4) {
                        ctx.fillStyle = "rgba(255,255,255,0.9)";
                        ctx.beginPath();
                        ctx.arc(pDx - pupilSize*0.3, pDy - pupilSize*0.3, pupilSize*0.25, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                };

                drawEye('left');
                drawEye('right');
                ctx.restore();
            }
        }

        // --- MINIMAP ---
        function drawMinimap(ctx) {
            const mRadius = MINIMAP_CONFIG.radius;
            const mMargin = MINIMAP_CONFIG.margin;
            
            const centerX = mMargin + mRadius;
            const centerY = mMargin + mRadius;

            ctx.save();
            ctx.resetTransform();

            const grad = ctx.createRadialGradient(
                centerX - mRadius * 0.3, centerY - mRadius * 0.3, mRadius * 0.1,
                centerX, centerY, mRadius
            );
            grad.addColorStop(0, MINIMAP_CONFIG.bgCenter);
            grad.addColorStop(1, MINIMAP_CONFIG.bgEdge);

            ctx.beginPath();
            ctx.arc(centerX, centerY, mRadius, 0, Math.PI * 2);
            ctx.clip(); 

            ctx.fillStyle = grad;
            ctx.fill(); 

            if (gameState.player) {
                const normX = gameState.player.x / WORLD_RADIUS;
                const normY = gameState.player.y / WORLD_RADIUS;

                const dist = Math.hypot(normX, normY);
                let pX, pY;
                
                if (dist > 1) {
                    const angle = Math.atan2(normY, normX);
                    pX = centerX + Math.cos(angle) * mRadius;
                    pY = centerY + Math.sin(angle) * mRadius;
                } else {
                    pX = centerX + normX * mRadius;
                    pY = centerY + normY * mRadius;
                }

                ctx.fillStyle = MINIMAP_CONFIG.playerColor;
                ctx.beginPath();
                ctx.arc(pX, pY, 3.5, 0, Math.PI*2);
                ctx.fill();
                
                ctx.shadowBlur = 6;
                ctx.shadowColor = MINIMAP_CONFIG.playerColor;
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.shadowBlur = 0; 
            }

            ctx.beginPath();
            ctx.arc(centerX, centerY, mRadius, 0, Math.PI * 2);
            ctx.lineWidth = 3;
            ctx.strokeStyle = MINIMAP_CONFIG.borderColor;
            
            ctx.shadowBlur = 10;
            ctx.shadowColor = "rgba(75, 0, 130, 0.7)"; 
            
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.shadowColor = "transparent";

            ctx.beginPath();
            ctx.arc(centerX, centerY, mRadius - 1, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        // --- BACKGROUND ---
        function drawBackground(ctx, camX, camY, timestamp) {
            const viewportW = gameState.width / gameState.gameZoom;
            const viewportH = gameState.height / gameState.gameZoom;

            ctx.fillStyle = '#000000'; 
            ctx.fillRect(camX, camY, viewportW, viewportH);

            const r = BG_CONFIG.hexSize;
            const xStep = 1.5 * r;
            const yStep = Math.sqrt(3) * r;

            const startCol = Math.floor(camX / xStep) - 1;
            const startRow = Math.floor(camY / yStep) - 1;
            const cols = Math.ceil(viewportW / xStep) + 2;
            const rows = Math.ceil(viewportH / yStep) + 2;

            for (let col = startCol; col < startCol + cols; col++) {
                for (let row = startRow; row < startRow + rows; row++) {
                    let hexWorldX = col * xStep;
                    let hexWorldY = row * yStep;
                    if (col % 2 !== 0) hexWorldY += yStep / 2;

                    const phase = Math.abs(getPseudoRandom(col, row) % (Math.PI * 2));
                    const sinVal = Math.sin(timestamp * BG_CONFIG.animSpeed + phase);
                    const normVal = (sinVal + 1) / 2;
                    const currentCenterL = BG_CONFIG.centerMinL + (BG_CONFIG.centerMaxL - BG_CONFIG.centerMinL) * normVal;

                    const colorCenter = `hsl(${BG_CONFIG.hue}, ${BG_CONFIG.saturation}%, ${currentCenterL}%)`;
                    const colorEdge = `hsl(${BG_CONFIG.hue}, ${BG_CONFIG.saturation}%, ${BG_CONFIG.lightnessEdge}%)`;
                    
                    const drawR = Math.max(0, r - (BG_CONFIG.hexGap / 2));
                    
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 180) * (60 * i);
                        const px = hexWorldX + drawR * Math.cos(angle);
                        const py = hexWorldY + drawR * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();

                    const gradient = ctx.createRadialGradient(hexWorldX, hexWorldY, 0, hexWorldX, hexWorldY, drawR);
                    gradient.addColorStop(0, colorCenter);
                    gradient.addColorStop(1, colorEdge);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }
        }

        // --- CONTROL MANAGER (NEW) ---
        const ControlManager = {
            mode: null, // 'desktop' or 'mobile'
            
            // For Mobile Logic
            joystickData: {
                active: false,
                id: null,
                origin: { x: 0, y: 0 },
                current: { x: 0, y: 0 },
                radius: 40 // Max drag radius
            },
            boostId: null,

            setMode: function(mode) {
                this.mode = mode;
                document.getElementById('control-modal').style.display = 'none';

                if (mode === 'desktop') {
                    this.initDesktop();
                    document.getElementById('desktop-hint').style.display = 'block';
                } else if (mode === 'mobile') {
                    this.initMobile();
                    document.getElementById('desktop-hint').style.display = 'none';
                    document.getElementById('hint-move').style.display = 'block';
                    document.getElementById('hint-boost').style.display = 'block';
                }
            },

            initDesktop: function() {
                // Original Event Listeners
                window.addEventListener('mousemove', e => {
                    gameState.mouseX = e.clientX;
                    gameState.mouseY = e.clientY;
                });
                window.addEventListener('mousedown', () => gameState.mouseDown = true);
                window.addEventListener('mouseup', () => gameState.mouseDown = false);
                
                // Keep default touch listeners as fallback for hybrid devices, but treat them as mouse
                window.addEventListener('touchmove', e => {
                    e.preventDefault();
                    if(e.touches.length > 0) {
                        gameState.mouseX = e.touches[0].clientX;
                        gameState.mouseY = e.touches[0].clientY;
                    }
                }, {passive: false});
                window.addEventListener('touchstart', () => gameState.mouseDown = true);
                window.addEventListener('touchend', () => gameState.mouseDown = false);
            },

            initMobile: function() {
                const joystickBase = document.getElementById('joystick-base');
                const joystickStick = document.getElementById('joystick-stick');
                
                // Handle all touches on window
                window.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scroll/zoom
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        const x = touch.clientX;
                        const y = touch.clientY;

                        // Left Half = Joystick (if not already active)
                        if (x < window.innerWidth / 2) {
                            if (!this.joystickData.active) {
                                this.joystickData.active = true;
                                this.joystickData.id = touch.identifier;
                                this.joystickData.origin = { x, y };
                                this.joystickData.current = { x, y };

                                // Show UI
                                joystickBase.style.display = 'block';
                                joystickBase.style.left = x + 'px';
                                joystickBase.style.top = y + 'px';
                                joystickStick.style.transform = `translate(-50%, -50%)`;
                                
                                // Hide tutorial hint
                                document.getElementById('hint-move').style.display = 'none';
                            }
                        } 
                        // Right Half = Boost
                        else {
                            this.boostId = touch.identifier;
                            gameState.mouseDown = true;
                            // Hide tutorial hint
                            document.getElementById('hint-boost').style.display = 'none';
                        }
                    }
                }, {passive: false});

                window.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        
                        // Update Joystick
                        if (this.joystickData.active && touch.identifier === this.joystickData.id) {
                            const dx = touch.clientX - this.joystickData.origin.x;
                            const dy = touch.clientY - this.joystickData.origin.y;
                            const distance = Math.hypot(dx, dy);
                            const angle = Math.atan2(dy, dx);

                            // Clamp visuals
                            const clampedDist = Math.min(distance, this.joystickData.radius);
                            const stickX = Math.cos(angle) * clampedDist;
                            const stickY = Math.sin(angle) * clampedDist;

                            joystickStick.style.transform = `translate(calc(-50% + ${stickX}px), calc(-50% + ${stickY}px))`;

                            // --- PROJECT INPUT TO GAME STATE ---
                            // We trick the game into thinking the mouse is far away in the direction of the joystick
                            const projectionDist = 500; 
                            gameState.mouseX = (gameState.width / 2) + Math.cos(angle) * projectionDist;
                            gameState.mouseY = (gameState.height / 2) + Math.sin(angle) * projectionDist;
                        }
                    }
                }, {passive: false});

                window.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];

                        // End Joystick
                        if (this.joystickData.active && touch.identifier === this.joystickData.id) {
                            this.joystickData.active = false;
                            this.joystickData.id = null;
                            joystickBase.style.display = 'none';
                            // Note: We don't reset mouseX/Y so the snake keeps moving in last known direction
                        }

                        // End Boost
                        if (touch.identifier === this.boostId) {
                            this.boostId = null;
                            gameState.mouseDown = false;
                        }
                    }
                }, {passive: false});
            }
        };

        // --- GAME LOOP ---
        function updateSize() {
            gameState.width = window.innerWidth;
            gameState.height = window.innerHeight;
            canvas.width = gameState.width;
            canvas.height = gameState.height;
            
            const currentArea = gameState.width * gameState.height;
            gameState.gameZoom = Math.sqrt(currentArea / GAME_CONFIG.targetVisibleArea);
            gameState.gameZoom = Math.max(0.1, Math.min(20.0, gameState.gameZoom));
        }

        function initGame() {
            updateSize();
            gameState.player = new Snake();

            window.addEventListener('resize', updateSize);
            // Input listeners are now handled by ControlManager.setMode()
        }

        let lastTime = 0;

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (deltaTime > 100) deltaTime = 100;

            const timeScale = deltaTime / 16.667;

            gameState.globalTime = timestamp;

            const pulse = Math.sin(timestamp * 0.002); 
            const dynamicRadius = WORLD_RADIUS + (pulse * 40); 
            gameState.currentWorldRadius = dynamicRadius;

            if (gameState.player) {
                gameState.player.update(timeScale);
                const viewW = gameState.width / gameState.gameZoom;
                const viewH = gameState.height / gameState.gameZoom;
                gameState.camera.x = gameState.player.x - viewW / 2;
                gameState.camera.y = gameState.player.y - viewH / 2;
            }

            ctx.resetTransform(); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. GAME WORLD
            ctx.scale(gameState.gameZoom, gameState.gameZoom);
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            drawBackground(ctx, gameState.camera.x, gameState.camera.y, timestamp);

            // Boundary
            const zoneThickness = 400; 
            const grad = ctx.createRadialGradient(0, 0, dynamicRadius, 0, 0, dynamicRadius + zoneThickness);
            grad.addColorStop(0, 'rgba(255, 50, 50, 0.6)');      
            grad.addColorStop(0.3, 'rgba(255, 0, 0, 0.2)');     
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');          

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius + zoneThickness, 0, Math.PI * 2); 
            ctx.arc(0, 0, dynamicRadius, 0, Math.PI * 2, true);           
            ctx.fill();

            ctx.lineWidth = 4;
            ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 + pulse * 0.2})`;
            ctx.beginPath();
            ctx.arc(0, 0, dynamicRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = "rgba(255, 50, 50, 0.15)";
            ctx.font = "200px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("âœ•", 0, 0); 

            if (gameState.player) {
                gameState.player.draw(ctx);
            }

            // --- INTERFACE LAYER ---
            ctx.resetTransform();
            
            // 2. VIGNETTE
            const maxDim = Math.max(gameState.width, gameState.height);
            const vRadius = Math.hypot(gameState.width/2, gameState.height/2); 
            const vGrad = ctx.createRadialGradient(
                gameState.width / 2, gameState.height / 2, vRadius * 0.4, 
                gameState.width / 2, gameState.height / 2, vRadius
            );
            vGrad.addColorStop(0, 'rgba(0,0,0,0)');
            vGrad.addColorStop(1, 'rgba(0,0,0,0.95)');
            
            ctx.fillStyle = vGrad;
            ctx.fillRect(0, 0, gameState.width, gameState.height);
            
            // 3. MINIMAP
            drawMinimap(ctx);

            requestAnimationFrame(gameLoop);
        }

        initGame();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>